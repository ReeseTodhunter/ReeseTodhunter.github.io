<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reese Programs A Thing</title>
    <link rel="stylesheet" href="ProjectPageStyles.css">
    <script src="https://kit.fontawesome.com/650c1785fc.js" crossorigin="anonymous"></script>
</head>
<body>
    <section id="top"></section>

    <!--Nav Bar Section-->
    <nav class="navbar">
        <div class="navbar__container">
            <a href="/index.html" id="navbar__logo">Reese Todhunter</a>
            <div class="navbar__toggle" id="mobile-menu">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="back"></span>
            </div>
            <ul class="navbar__menu">
                <li class="navbar__btn">
                    <a href="/index.html#about" class="button"><i class="fa-solid fa-circle-info"></i>About</a>
                </li>
                <li class="navbar__btn">
                    <a href="/index.html#projects" class="button"><i class="fa-solid fa-laptop-code"></i>Projects</a>
                </li>
                <li class="navbar__btn">
                    <a href="/pdf/Reese_Todhunter-CV.pdf" target="_blank" class="button"><i class="fa-solid fa-file-lines"></i>CV</a>
                </li>
                <li class="navbar__btn">
                    <a href="/index.html#contact" class="button"><i class="fa-solid fa-message"></i>Contact</a>
                </li>
            </ul>
        </div>
    </nav>

    <section class="project">
        <div class="project">
            <div class="project__title">
                <h1>Byle</h1>
            </div>
            <div class="project__background" style = "background-color: #0e5210;">
                <div class="video__wrapper">
                    <video src="videos/Byle Trailer.mp4" alt="video" id="main__video"
                     style = "width: 100%; height: 100%;" controls poster = "images/Byle Thumbnail.png"></video>
                </div>
                <div class = "project__info">
                    <p><br/>
                        BYLE was built as a final group project at <a href = "https://www.glos.ac.uk/" target="_blank">The University of Gloucestershire</a>.<br/>
                        We had a complete team size of 8 students, made up of 5 programmers, 2 designers and 1 animator.<br/>
                        Created using the Unity Engine and coded entirely in C#. <br/>
                        <a href = "https://store.steampowered.com/app/2517000/BYLE/" target="_blank">The game is also now available on Steam!</a><br/><br/>
                        
                        <div class = "dropdown">
                            <button class="dropdown__button">
                                Main Contributions
                            </button>

                            <div class = "dropdown__content">
                                <div class ="dropdown__text">
                                    My main contributions to the project were the player controller, weapon code, powerup/modifer systems, and steam integration.<br/>
                                </div>

                                <div class = "dropdown">
                                    <button class="dropdown__button">
                                        Player Controller
                                    </button>
        
                                    <div class = "dropdown__content">
                                        <div class ="dropdown__text">
                                            The player controller inherits from a base Character class. I created this class for use in both the Player and AI controllers.<br/>
                                            Where it supports all of the base functions the player and enemies may need such as taking damage, healing, dying and gaining status effects.<br/>
                                            This base class can be seen is this dropdown.
                                        </div>
                                        <div class = "dropdown">
                                            <button class="dropdown__button" style = "background-color: rgb(54, 141, 158); scale: 80%;">
                                                Character Code
                                            </button>
                                            <div class = "dropdown__content">
                                                <div class = "code__container">
                                                    <div class = "dropdown__codeblock">
<pre><code class="language-csharp">
    public class Character : MonoBehaviour
    {
        public int characterID;
        // Button above player that can be used to display a debug message
        // Off by default in hierarchy
        [SerializeField] public Text debugButton;
    
        // Character Stats
        [SerializeField] protected float baseMaxHealth; // Max health before modifiers
        protected float maxHealth; // Max health after modifiers
        protected float health = 0.0f; // Current health of character
    
        // Speed
        [SerializeField] float speedDefault = 0.0f; // Speed value without any modifiers attached
        protected float speed = 0.0f; // Speed of character after modifiers
    
        // Immunity
        [SerializeField] GameObject immuneIndicator;
        protected bool isInvulnerable = false; // True if the character is currently immune to all damage
        float invulnerableTimer = 0.0f; // How long the character is invulnerable for
    
        // Status Effects
        // General
        List<StatusEffect> statusEffects = new List<StatusEffect>(); // List of every status effect on the character
        List<GameObject> statusIndicators = new List<GameObject>(); // Currently active indicators indicating the characters statuses. Indication.
        // Burn
        [SerializeField] GameObject burnIndicator;
        bool isBurning = false;
        // Poison
        [SerializeField] GameObject poisonIndicator;
        protected bool isPoisoned = false;
        protected bool isStunned = false;
        // Byle
        [SerializeField]
        public bool BYLEBoosted = false;
        //Score
        public int score = 0;
    
        // Attributes / Modifiers
        List<Modifier> modifiers = new List<Modifier>(); // Modifiers
    
        //Particle Effects
        private GameObject burnVFX;
        private GameObject stunVFX;
        private GameObject poisonVFX;
    
    
        // HEALTH
        public virtual void Damage(float dmg, bool ignoreImmunity = false, bool grantImmunity = true, bool ignoreResistance = false, EffectType _effectType = EffectType.None, bool _isCrit = false)
        {
            if(health > 0.0f)
            {
                if (!isInvulnerable || (isInvulnerable && ignoreImmunity))
                {
                    float damageTaken = 0.0f;
                    if (ignoreResistance)
                    {
                        damageTaken = Mathf.Max(0.0f, dmg);
                    }
                    else
                    {
                        damageTaken = Mathf.Max(0.0f, dmg * Mathf.Max(0.1f, (1.0f + GetModifier(ModifierType.Vulnerability))));
                    }
    
                    health -= damageTaken;
                    if (health <= 0.0f)
                    {
                        Die();
                    }
    
                    // TEMPORARY TEXT FOR DEBUGGING :))))
                    if (dmg != 0)
                    {
                        GameObject floatingText = Instantiate(ProjectileLibrary.instance.GetProjectile(Projectiles.FLOATING_TEXT), transform.position + Vector3.up * 1.5f + Vector3.one * Random.Range(-0.2f, 0.2f), Quaternion.Euler(Vector3.zero));
                        floatingText.GetComponent<ItemPickupFade>().SetText((Mathf.Round(damageTaken*10.0f)/10.0f).ToString(), _effectType, _isCrit);
                    }
    
                    OnDamage(damageTaken, ignoreImmunity, grantImmunity, ignoreResistance, _effectType,_isCrit);
                }
            }
            
    
            // Check if dead
            //Maybe Remove this later?
            if (health <= 0.0f && !isInvulnerable)
            {
                Die();
            }
        }
        public float Heal(float heal)
        {
            float oldHealth = health;
    
            health += Mathf.Max(0.0f, heal);
            health = Mathf.Min(health, maxHealth); // Making sure health didn't go over cap
            OnHeal(heal);
            
            if (CameraDamageEffect.instance != null)
            {
                if (GetHealth()>GetMaxHealth()/2) CameraDamageEffect.instance.SetMinOpacity();
            }
            return health - oldHealth;
        }
        public virtual void OnHeal(float _heal){}
        public float GetHealth()
        {
            return health;
        }
        public float GetMaxHealth()
        {
            return maxHealth;
        }
        protected virtual void Die()
        {
            Destroy(gameObject);
        }
        protected virtual void OnDamage(float dmg, bool ignoreImmunity = false, bool grantImmunity = true, bool ignoreResistance = false, EffectType type = EffectType.None, bool _isCrit = false)
        {
            return;
        }
    
        // DAMAGE
        public virtual void OnDamageDealt(float dmg)
        {
            Heal(dmg * GetModifier(ModifierType.Vampirism));
        }
    
        // BYLE
        public virtual void BYLEInteraction()
        {
            //Override this in the player character and enemy scripts
            //For enemies, this may not work due to the behaviour tree
        }
    
        // INVULNERABILITY
        public void Protect(float time)
        {
            if (invulnerableTimer < time) { invulnerableTimer = time; }
            isInvulnerable = true;
            UpdateIndicator(immuneIndicator, true);
        }
        public bool IsInvulnerable()
        {
            return isInvulnerable;
        }
    
        // STATUS EFFECTS
        private void AddStatus(StatusType a_type, EffectType a_effect, float a_damage, float a_maxTime, float a_tickTime = 1.0f)
        {
            // Should not be called directly
            // Also do not add 2 status effects of the same "effect" type (except "None") and different lengths
            // This WILL mess up how the character knows what status effect it has
            // And it will be YOUR fault and definitely not mine
            // That being said if you want to improve it go ahead
            statusEffects.Add(new StatusEffect(a_type, a_effect, this, a_damage, a_maxTime, a_tickTime));
        }
        public void Burn(float time, float tickDmg)
        {
            // Check if the character is currently invulnerable to everything
            if (!isInvulnerable)
            {
                // Check if the character is already burning and determine if pre-existing burn should be overwritten
                if (isBurning)
                {
                    // Find the other matching status effect
                    List<StatusEffect> removedStatuses = new List<StatusEffect>();
                    foreach(StatusEffect effect in statusEffects)
                    {
                        if (effect != null && effect.MatchingStatus(StatusType.Damage, EffectType.Burn)) // Check for a damage & burn status
                        {
                            // Return early if time remaining on current burn is longer than new burn, so new burn is ignored
                            if (effect.TimeRemaining() >= time)
                            {
                                return;
                            }
    
                            removedStatuses.Add(effect); // Remove old status since it will now be replaced
                        }
                    }
                    // Clearing overwritten status effects from list
                    foreach (StatusEffect effect in removedStatuses)
                    {
                        statusEffects.Remove(effect);
                    }
                }
                
                // Apply status effect
                AddStatus(StatusType.Damage, EffectType.Burn, tickDmg, time, 0.5f); // MAGIC NUMBER (tick time)
    
                // Other values
                isBurning = true;
                UpdateIndicator(burnIndicator, true);
            }
        }
        public bool IsBurning()
        {
            return isBurning;
        }
        public void Poison(float time, float tickDmg, float speedMultiplier)
        {
            if (!isInvulnerable)
            {
                // Check if the character is already burning and determine if pre-existing poison should be overwritten
                if (isPoisoned)
                {
                    // Find the other matching status effects
                    bool overwriteEffect = false;
                    List<StatusEffect> removedStatuses = new List<StatusEffect>();
                    foreach (StatusEffect effect in statusEffects)
                    {
                        if (effect != null && effect.GetEffectType() == EffectType.Poison)
                        {
                            // Return early if time remaining on current poison is longer than new poison, so new poison is ignored
                            // In theory there shouldn't be 2 different poison effects with different times
                            // If there is then this overwrite code is flawed and could potentially allow for stacked poison effects
                            // But that shouldn't happen as long as AddEffect() is used properly :)
                            if (!overwriteEffect && effect.TimeRemaining() >= time)
                            {
                                return;
                            }
                            else
                            {
                                overwriteEffect = true;
                                removedStatuses.Add(effect);
                            }
                        }
                    }
                    // Clearing overwritten status effects from list
                    foreach (StatusEffect effect in removedStatuses)
                    {
                        statusEffects.Remove(effect);
                    }
                }
    
                // Apply status effect
                AddStatus(StatusType.Damage, EffectType.Poison, tickDmg, time, 1.0f); // MAGIC NUMBER (tick time)
                AddStatus(StatusType.Speed, EffectType.Poison, speedMultiplier, time);
    
                // Other values
                isPoisoned = true;
                UpdateIndicator(poisonIndicator, true);
            }
        }
        public bool IsPoisoned()
        {
            return isPoisoned;
        }
        public virtual void Stun(float time)
        {
            if (!isInvulnerable)
            {
                // Check if the character is already burning and determine if pre-existing poison should be overwritten
                if (isStunned)
                {
                    // Find the other matching status effects
                    bool overwriteEffect = false;
                    List<StatusEffect> removedStatuses = new List<StatusEffect>();
                    foreach (StatusEffect effect in statusEffects)
                    {
                        if (effect != null && effect.GetEffectType() == EffectType.Stun)
                        {
                            // Return early if time remaining on current poison is longer than new poison, so new poison is ignored
                            // In theory there shouldn't be 2 different poison effects with different times
                            // If there is then this overwrite code is flawed and could potentially allow for stacked poison effects
                            // But that shouldn't happen as long as AddEffect() is used properly :)
                            if (!overwriteEffect && effect.TimeRemaining() >= time)
                            {
                                return;
                            }
                            else
                            {
                                overwriteEffect = true;
                                removedStatuses.Add(effect);
                            }
                        }
                    }
                    // Clearing overwritten status effects from list
                    foreach (StatusEffect effect in removedStatuses)
                    {
                        statusEffects.Remove(effect);
                    }
                }
    
                // Apply status effect
                AddStatus(StatusType.inputLocked, EffectType.Stun, 0, time, 1.0f); // MAGIC NUMBER (tick time)
                // Other values
                isStunned = true;
            }
        }
        public bool IsStunned()
        {
            return isStunned;
        }
        protected virtual void OnStunEnd()
        {
        }
        // ATTRIBUTE MODIFIERS
        public void AddModifier(ModifierType modType, float modAmount)
        {
            modifiers.Add(new Modifier(modType, modAmount));
    
            // Any other active effects caused by adding modifiers
            switch (modType)
            {
                case ModifierType.MaxHealth:
                    maxHealth = Mathf.Max(1.0f, baseMaxHealth + GetModifier(ModifierType.MaxHealth));
                    Heal(modAmount);
                    if (health > maxHealth) health = maxHealth; // Lower health if it is greater than the max
                    break;
            }
        }
        public float GetModifier(ModifierType modType)
        {
            float modTotal = 0.0f;
    
            // really cringe rate of fire specific multiplicative modifer thing
            if (modType == ModifierType.RateOfFire)
            {
                modTotal = 1.0f;
                foreach (Modifier modifier in modifiers)
                {
                    if (modifier.type == modType) modTotal *= 1-modifier.value;
                }
                return modTotal;
            }
    
            foreach (Modifier modifier in modifiers)
            {
                if (modifier.type == modType) modTotal += modifier.value;
            }
            
            return modTotal;
        }
        public void RemoveModifier(ModifierType modType, float modAmount)
        {
            // Attempt to find modifer keyvaluepair inside dictionary and remove it
            foreach (Modifier modifier in modifiers)
            {
                if (modifier.type == modType && modifier.value == modAmount)
                {
                    modifiers.Remove(modifier);
                    return;
                }
            }
    
            // Add negative modifier if item couldn't be removed
            Debug.LogWarning("MODIFIER OF TYPE: " + modType.ToString() + " AND VALUE: " + modAmount.ToString() + " COULD NOT BE REMOVED. ADDING NEGATIVE MODIFIER.");
            modifiers.Add(new Modifier(modType, -modAmount));
        }
        public List<Modifier> GetModifierList()
        {
            return modifiers;
        }
        // UTILITY
        protected void UpdateIndicator(GameObject indicator, bool enabled) // Used for updating status effect icons
        {
            if (indicator != null)
            {
                if (enabled && !statusIndicators.Contains(indicator))
                {
                    statusIndicators.Add(indicator);
                    indicator.SetActive(true);
                }
                else if (!enabled && statusIndicators.Contains(indicator))
                {
                    statusIndicators.Remove(indicator);
                    indicator.SetActive(false);
                }
            }
        }
    
        // CHARACTER UPDATES
        private void Awake()
        {
            CharacterAwake();
        }
        protected void CharacterAwake()
        {
            if(this.gameObject.GetComponent<BTAgent>() != null)
            {
                if (this.GetComponent<BTAgent>().enemyType == BTAgent.EnemyType.Boss)
                {
                    baseMaxHealth = baseMaxHealth + (Mathf.CeilToInt((baseMaxHealth / 2) * GameManager.GMinstance.healthDifficultyScale));
                }
                else
                {
                    Debug.Log("Enemies Health scaled with level");
                    baseMaxHealth = baseMaxHealth + (Mathf.CeilToInt((baseMaxHealth / 10) * GameManager.GMinstance.healthDifficultyScale));
                    Debug.Log(health);
                }
                
            }
            health = baseMaxHealth;
            speed = speedDefault;
    
    
            //init debuff effects
            burnVFX = GameObject.Instantiate(Resources.Load("VFX/Debuffs/Burn") as GameObject,Vector3.zero,Quaternion.identity);
            burnVFX.transform.parent = this.transform;
            burnVFX.transform.localPosition = Vector3.zero;
            burnVFX.gameObject.layer = transform.gameObject.layer;
    
            stunVFX = GameObject.Instantiate(Resources.Load("VFX/Debuffs/Stun") as GameObject,Vector3.zero,Quaternion.identity);
            stunVFX.transform.parent = this.transform;
            stunVFX.transform.localPosition = Vector3.zero;
            stunVFX.gameObject.layer = transform.gameObject.layer;
    
            poisonVFX = GameObject.Instantiate(Resources.Load("VFX/Debuffs/Poison") as GameObject,Vector3.zero,Quaternion.identity);
            poisonVFX.transform.parent = this.transform;
            poisonVFX.transform.localPosition = Vector3.zero;
            poisonVFX.gameObject.layer = transform.gameObject.layer;
        
        }
    
        private void Update()
        {
            CharacterUpdate(); 
        }
        protected void CharacterUpdate()
        {
            // HEALTH
            maxHealth = Mathf.Max(1.0f, baseMaxHealth + GetModifier(ModifierType.MaxHealth));
            if (health > maxHealth) health = maxHealth; // Lower health if it is greater than the max
    
            // INVULNERABILITY
            if (isInvulnerable)
            {
                invulnerableTimer -= Time.deltaTime;
                if (invulnerableTimer <= 0.0f)
                {
                    isInvulnerable = false;
                    UpdateIndicator(immuneIndicator, false);
                }
            }
    
            //status vfx update
            UpdateDebuffParticleSystem(burnVFX,isBurning);
            UpdateDebuffParticleSystem(poisonVFX,isPoisoned);
            UpdateDebuffParticleSystem(stunVFX,isStunned, true);
    
            //BYLE
            if (BYLEBoosted)
            {
                //Generic Override, implement individual interactions in the character scripts
                BYLEInteraction();
                //Make sure every BYLEInteraction override has a flag to turn off BYLE Boost
                //BYLEBoosted = false;
            }
    
            // STATUS EFFECTS
            // Resetting speed modifier, as it will be changed by the following status effects (if any)
            List<StatusEffect> removedStatuses = new List<StatusEffect>();
            // Updating each status effect
            foreach (StatusEffect effect in statusEffects)
            {
                if (effect == null) {
                    removedStatuses.Add(effect);
                    continue;
                }
    
                effect.Update();
    
                if (effect.IsOver())
                {
                    switch (effect.GetEffectType()) {
                        case EffectType.Burn:
                            isBurning = false;
                            UpdateIndicator(burnIndicator, false);
                            break;
                        case EffectType.Poison:
                            isPoisoned = false;
                            UpdateIndicator(poisonIndicator, false);
                            break;
                        case EffectType.Stun:
                            isStunned = false;
                            break;
                    }
                    removedStatuses.Add(effect);
                    continue;
                }
            }
            // Clearing all finished status effects from list
            foreach (StatusEffect effect in removedStatuses)
            {
                statusEffects.Remove(effect);
                if(effect.GetEffectType() == EffectType.Stun){OnStunEnd();}
            }
            // Updating UI for status effects
            for (int i = 0; i < statusIndicators.Count; ++i)
            {
                GameObject indicator = statusIndicators[i];
                float width = indicator.GetComponent<RectTransform>().sizeDelta.x; // Width of the indicator icon. If the size of these aren't all equal this will probably break
                float spacing = 55.0f;
    
                // Calculates the position of that indicator so all that are active on the character are centred nicely
                indicator.transform.localPosition = new Vector3(spacing*i - 0.5f*(statusIndicators.Count-1)*spacing, indicator.transform.localPosition.y, indicator.transform.localPosition.z);
            }
    
            // Updating for the characters new speed with modifiers applied
            speed = speedDefault * Mathf.Max(0.0f, 1.0f + GetModifier(ModifierType.Speed));
        }
        private void UpdateDebuffParticleSystem(GameObject pSystem, bool _debuffState, bool _clearParticles = false)
        {
            if(!_debuffState)
            {
                pSystem.GetComponent<ParticleSystem>().Stop();
                if(_clearParticles){pSystem.GetComponent<ParticleSystem>().Clear();}
                return;
            }
            if(pSystem.GetComponent<ParticleSystem>().isPlaying){return;}
            pSystem.GetComponent<ParticleSystem>().Play();
        }
    }
    
    
    public class Modifier
    {
        public Modifier(ModifierType type, float value)
        {
            this.type = type;
            this.value = value;
        }
    
        public ModifierType type { get; set; }
        public float value { get; set; }
    }
    
    // Different types of modifiers that the character can have changed against it
    public enum ModifierType
    {
        Accuracy,
        Damage,
        MaxHealth,
        RateOfFire,
        Speed,
        Vulnerability,
        ProjectileSpeed,
        ProjectileSize,
        ReloadTime,
        ReloadForgiveness,
        ClipSize,
        Vampirism,
        DodgeRollRing,
        RollCharges,
        Pierce,
        CoinHeal,
        EnemyExplosion,
        CritChance,
        Discount,
        ExtraCoinChance,
        CooldownReduction
    }
</code></pre>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        <div class ="dropdown__text">
                                            The Player Controller on the other hand was coded to handle anything specific to the player such as animations, the stats and equipment of the selected character, player movement, item interactions, audio and finally, weapon switching and usage.<br/>
                                            Ontop of this the Player Controller overwrites a few of the base Character functions to add more player specific interactions to the existing functions.<br/>
                                            These include things like checking if the player is rolling in the damage check so to not apply damage to the player if they are supposed to be invulnerable.<br/>
                                            Again all of the Player Controller Code can be found in the below drop down.
                                        </div>
                                        <div class = "dropdown">
                                            <button class="dropdown__button" style = "background-color: rgb(54, 141, 158); scale: 80%;">
                                                Player Controller Code
                                            </button>
                                            <div class = "dropdown__content">
                                                <div class = "code__container">
                                                    <div class = "dropdown__codeblock">
<pre><code class="language-csharp">
public class PlayerController : Character
{
    HighScoreDisplay HighScoreDisplay;

    // General
    public static PlayerController instance;
    Rigidbody rb;
    private Animator animator;
    private int coins = 0;

    //Audio
    public List<AudioClip> damageAudio = null;    //Audio for taking a hit
    public List<AudioClip> pickupAudio = null;    //Item get sound effect
    public List<AudioClip> abilitySounds = null;

    // Movement
    bool freezeGameplayInputs = false; // Set to true to stop player from
    Vector3 previousMousePos;

    // Dodge Roll
    public GameObject rollIndicator;
    public float rollSpeed; // How fast the player will roll
    public float rollLength; // How long a roll will last in seconds
    public float rollCooldownLength; // Time between each roll in seconds
    float rollTimer;
    float rollCooldownTimer;
    int rollCharges; // Amount of rolls the player currently has
    Vector3 rollDirection; // Direction of the roll

    // Active Ability
    public BaseActivePowerup currentAbility;
    float abilityTimer = 0.0f;

    // Weapon Fire
    public BaseWeapon primaryWeapon;
    public BaseWeapon secondaryWeapon;
    public Transform weaponParent;
    public Transform secondaryParent;
    public Transform modelCentre;
    bool canUseWeapons = true;
    float weaponSwapTime = 0.0f; // Used to stop firing weapons immediately after swapping
    private float scrollTimer = 0; // Used to stop the player from swapping weapons extremely fast

    //Weapon Specials
    public int NumOfChicks;

    //Misc
    private Vector3 directionOfMovement = Vector3.zero;
    public GameObject model;
    private Vector3 aimPos;
    private bool isRolling = false;

    // Character classes
    public enum SelectedCharacter
    {
        VLAD,
        MIKE,
        RAMBO,
        OL_ONE_EYE,
        DART,
        KARLOS,
        XERXES,
        KYLE
    }
    public SelectedCharacter currCharacter = SelectedCharacter.RAMBO;
    public Transform decor;

    // Achievement flags
    public bool playerHitInRoom = false;
    public bool playerHitInLevel = false;

    private void Awake()
    {
        // Instance for the enemy AIs
        if (instance != null)
        {
            if (instance != this)
            {
                Destroy(this);
            }
        }
        instance = this;

        
        // Getting rigidbody component
        rb = GetComponent<Rigidbody>();
        if (rb == null)
        {
            Debug.LogError("You are stupid. Give the player a rigidbody.");
        }
        animator = this.GetComponent<Animator>();
        
        if(primaryWeapon != null)
        {
            primaryWeapon.GetComponent<Collider>().enabled = false;
            primaryWeapon.GetComponent<BaseWeapon>().currState = BaseWeapon.WeaponState.EQUIPPED;
            animator.Play(primaryWeapon.GetIdleAnimName());
        }
        if(secondaryWeapon != null)
        {
            secondaryWeapon.GetComponent<Collider>().enabled = false;
            secondaryWeapon.OnStow();
        }
        // Character awake code
        CharacterAwake();
        if(GameManager.GMinstance == null){return;}
        if (!GameManager.GMinstance.loadGame)
        {
            if (SceneManager.GetActiveScene().name == "BUILD")
            {
                SetPlayerCharacter();
            }
        }

    }
    private void Update()
    {
        CharacterUpdate(); // Inherited from character. Runs all character updates (status effects and other)
        if (!freezeGameplayInputs)
        {
            Movement(); // Runs the movement code for the player
            DodgeRoll(); // Checks if the player has dodge rolled and runs any dodge roll functionality
            ItemInteract(); // Checks if the player is picking up an item
            ActiveAbility(); // Activates any abilities the player uses

            // Weapons
            if (canUseWeapons && !isStunned)
            {
                UpdateWeapon(); // Attempts to fire weapons and any other functionality they may have
                SwitchWeapon(); // Attempts to switch weapons
            }
        }

        if (modelCentre != null) { ObstacleHidingScript.SetPlayerScreenPosition(transform); } // For showing player through objects
    }
    private void LateUpdate()
    {
        if(rollTimer > 0){return;} // If the player is rolling do not update aim
        if (!freezeGameplayInputs)
        {
            Aim(); // Updates the players current aim
        }
    }
    // Update Functions
    void Movement()
    {
        // ---------------------------------------------------------
        // MOVEMENT
        // ---------------------------------------------------------
        rb.velocity = new Vector3(0.0f, rb.velocity.y, 0.0f); // Reset velocity

        if (rollTimer <= 0.0f && (Input.GetAxisRaw("MoveH") != 0 || Input.GetAxisRaw("MoveV") != 0))
        {
            Vector3 direction = new Vector3(Input.GetAxisRaw("MoveH"), 0, Input.GetAxisRaw("MoveV"));
            direction.Normalize();
            directionOfMovement = direction;
            rb.velocity = direction * (speed / Time.timeScale);
            //Debug.Log("Direction: X:" + direction.x + " Z:" + direction.z + " | Velocity: X:" + rb.velocity.x + " Z:" + rb.velocity.z +" | Roll Timer:" + rollTimer);
        }
    }

    void DodgeRoll()
    {
        // ---------------------------------------------------------
        // DODGE ROLL
        // ---------------------------------------------------------
        // TO-DO:
        // � Better implementation for locking abilities during a roll

        // Start roll (User has pressed roll key and direction)
        if (Input.GetButtonDown("Roll") && rollCharges > 0 && (Input.GetAxisRaw("MoveH") != 0 || Input.GetAxisRaw("MoveV") != 0))
        {
            //Debug.Log("ROLL START!!!!");

            // Hide roll indicator if it is currently active
            rollIndicator.SetActive(false);

            // I-Frames
            Protect(rollLength);

            // Decrease roll charges
            rollCharges--;

            // Get roll direction
            rollDirection = new Vector3(Input.GetAxisRaw("MoveH"), 0, Input.GetAxisRaw("MoveV"));
            rollDirection.Normalize();

            // Start roll timer
            rollTimer = rollLength; // Start roll timer
            rollCooldownTimer = rollCooldownLength; // Start roll cooldown timer (starts when rollTimer hits 0)

            // ANIMATION
            // Setting speed the of the roll animation based off time of the roll set in inspector
            animator.speed = 1 / rollLength;
            // Freeze all rigidbody rotation (stops animation freaking out when rolling into wall)
            rb.constraints = RigidbodyConstraints.FreezeRotation;
            // Roll animation
            switch (GetMovementDirection())
            {
                case PlayerMoveDirection.Forwards:
                    animator.Play("RollForward");
                    break;
                case PlayerMoveDirection.Backwards:
                    animator.Play("RollBackward");
                    break;
                case PlayerMoveDirection.Left:
                    animator.Play("RollLeft");
                    break;
                case PlayerMoveDirection.Right:
                    animator.Play("RollRight");
                    break;
                default:
                    break;
            }

            // Fire bullet ring if player has said ability
            GameObject rollProjectile = ProjectileLibrary.instance.GetProjectile(Projectiles.GENERIC_PLAYER_BULLET);
            int rollBullets = (int)GetModifier(ModifierType.DodgeRollRing);
            if (rollBullets > 0 && rollProjectile != null)
            {
                float bulletAngle = 360.0f / rollBullets;
                for (int i = 0; i < rollBullets; ++i)
                {
                    Instantiate(rollProjectile, transform.position + Vector3.up, Quaternion.Euler(0, bulletAngle * i, 0)).GetComponent<Projectile>()
                        .Init(30.0f * (1.0f + GetModifier(ModifierType.ProjectileSpeed)), 0.0f, 3.0f, 1.0f * (1.0f + GetModifier(ModifierType.Damage)), this.gameObject)
                        .SetPierce((int)PlayerController.instance.GetModifier(ModifierType.Pierce), 1.0f)
                        .SetCrit(Random.Range(0,10) == 0, 1.25f);
                }
            }

            isRolling = true;
        }

        // During roll (Roll timer is counting down)
        if (rollTimer > 0.0f)
        {
            //transform.LookAt(transform.position - rollDirection); // Look in roll direction

            rb.velocity = rollDirection * rollSpeed * (1+GetModifier(ModifierType.Speed)) / Time.timeScale; // Move in roll direction

            rollTimer -= Time.unscaledDeltaTime; // Decrease roll timer
        }

        // End of the roll (Roll timer is finished and now cooldown timer is counting down)
        if (rollTimer <= 0.0f && rollCooldownTimer > 0.0f)
        {
            // Reset rigidbody constraints back to normal so player can walk properly into walls again
            rb.constraints = RigidbodyConstraints.FreezeRotationX | RigidbodyConstraints.FreezeRotationZ;

            // Decrease roll cooldown timer
            rollCooldownTimer -= Time.unscaledDeltaTime * (1.0f + GetModifier(ModifierType.CooldownReduction));

            // Update player canvas UI
            rollIndicator.SetActive(true);
            rollIndicator.GetComponent<Slider>().value = GetRollCooldown();
            if(isRolling)
            {
                animator.speed = 1;
                isRolling = false;
                if(primaryWeapon != null)
                {
                    animator.Play(primaryWeapon.GetIdleAnimName());
                }
            }
            
        }

        // End of roll cooldown and missing a roll charge (The roll cooldown has finished)
        if (rollCooldownTimer <= 0.0f && rollCharges < 1+GetModifier(ModifierType.RollCharges))
        {
            rollCharges++;

            if (rollCharges < 1 + GetModifier(ModifierType.RollCharges))
            {
                rollCooldownTimer = rollCooldownLength;
            }

            else
            {
                rollIndicator.SetActive(false);
            }
        }
    }

    void Aim()
    {
        //Check if the mouse has moved
        if (previousMousePos != Input.mousePosition)
        {
            // Create a ray at the mouses position on screen
            var ray = Camera.main.ScreenPointToRay(Input.mousePosition);

            // Cast the ray from the mouse position out into the scene if hitting the ground layer turning the model to face the collision point
            if (rollTimer <= 0.0f && Physics.Raycast(ray, out var hitInfo, Mathf.Infinity, 1 << 6))
            {
                transform.LookAt(new Vector3(hitInfo.point.x, transform.position.y, hitInfo.point.z - weaponParent.position.y));
                aimPos = new Vector3(hitInfo.point.x, transform.position.y, hitInfo.point.z - weaponParent.position.y);
            }
            previousMousePos = Input.mousePosition;
        }
        
        // Controller aim
        else if (rollTimer <= 0.0f && (Input.GetAxisRaw("AimH") != 0 || Input.GetAxisRaw("AimV") != 0))
        {
            Vector3 direction = new Vector3(Input.GetAxisRaw("AimH"), 0, Input.GetAxisRaw("AimV"));
            transform.LookAt(transform.position + direction);
            aimPos = transform.position + direction;
        }
    }

    void ItemInteract()
    {
        //Check if player trying to interact
        if (!Input.GetButtonDown("Interact"))
        {
            return;
        }

        // Get all objects nearby
        Collider[] cols = Physics.OverlapSphere(transform.position, 5);
        // Get the closest item to you
        int itemType = -1; // 0 = weapon, 1 = active powerup
        float closestDistance = 999.9f;
        BaseWeapon closestWeapon = null; ;
        BaseActivePowerup closestActivePowerup = null;

        // Iterate through each collider found in pick up range
        foreach (Collider col in cols)
        {
            if (closestDistance > Vector3.Distance(transform.position, col.transform.position))
            {
                // If the collider is a weapon and mark it as closest item if thats the case
                if (col.gameObject.TryGetComponent<BaseWeapon>(out BaseWeapon weapon))
                {
                    itemType = 0;
                    closestWeapon = weapon;
                    closestDistance = Vector3.Distance(transform.position, col.transform.position);
                }

                // Same as above but for abilities
                else if (col.gameObject.TryGetComponent<BaseActivePowerup>(out BaseActivePowerup activePowerup))
                {
                    if (activePowerup.IsEquipped()) continue; // Ignore abilities that are already equipped
                    itemType = 1;
                    closestActivePowerup = activePowerup;
                    closestDistance = Vector3.Distance(transform.position, col.transform.position);
                }
            }
        }

        // Pick up whatever item was found
        switch (itemType)
        {
            case 0:
                PickupWeapon(closestWeapon);
                break;
            case 1:
                PickupAbility(closestActivePowerup);
                break;
        }
    }

    // Picks up an active ability powerup
    public void PickupAbility(BaseActivePowerup a_ability)
    {
        // No current ability
        if (currentAbility == null)
        {
            // Equip ability
            currentAbility = a_ability;
            currentAbility.Equip();
        }

        // Already ability equipped
        else
        {
            // Equip new and unequip old ability
            BaseActivePowerup oldAbility = currentAbility;
            currentAbility = a_ability;

            currentAbility.Equip();
            oldAbility.Unequip();

            // If old ability was still on cooldown restart the cooldown timer for the new powerup
            // This prevents players from swapping between 2 powerups for no cooldown times
            if (abilityTimer > 0.0f)
            {
                abilityTimer = currentAbility.GetCooldownTime();
            }
        }
    }

    // Called to check if the player is using their active ability
    void ActiveAbility()
    {
        if (abilityTimer <= 0.0f) // If not on cooldown
        {
            if (!isRolling && currentAbility != null && Input.GetButtonDown("Ability")) // If the player is pressing the button
            {
                abilityTimer = currentAbility.UseAbility(); // Use ability

                PlayAudio(abilitySounds);

                // If timer is -1 it means that the ability can no longer be used
                if (abilityTimer == -1.0f) {
                    Destroy(currentAbility.gameObject);
                    currentAbility = null;
                }
            }
        }
        else
        {
            abilityTimer -= Time.unscaledDeltaTime * (1.0f + GetModifier(ModifierType.CooldownReduction)); // Reduce ability cooldown timer
        }
    }

    // Plays the sound cue for picking up items
    public void PlayItemPickup()
    {
        PlayAudio(pickupAudio);
    }

    // Plays a given audio clips
    private void PlayAudio(List<AudioClip> audioClips)
    {
        if (audioClips.Count > 0)
        {
            //Get the audio source component and check it's not already playing something
            if (gameObject.TryGetComponent(out AudioSource audioSource) && !audioSource.isPlaying)
            {
                //Play a random audio clip from the available clips
                audioSource.clip = audioClips[Random.Range(0, audioClips.Count)];
                //Randomise the audio pitch
                audioSource.pitch = Random.Range(0.8f, 1.2f);
                //Set Audio volume
                audioSource.volume = GameManager.GMinstance.FXVolume;
                //Play randomised audio
                audioSource.Play();
            }
        }
    }

    // Damages the player
    // All the override does is check for an achievement, actual functionality is the same as the character.
    public override void Damage(float dmg, bool ignoreImmunity = false, bool grantImmunity = true, bool ignoreResistance = false, EffectType _effectType = EffectType.None, bool _isCrit = false)
    {
        // Achievement 18 check
        if (isRolling && Time.timeScale != 1.0f)
        {
            AchievementSystem.UnlockAchievement(18);
            AchievementSystem.Init();
            SaveLoadSystem.instance.SaveAchievements();
            GameManager.GMinstance.UnlockSteamAchievement("The_Matrix");
        }

        base.Damage(dmg, ignoreImmunity, grantImmunity, ignoreResistance, _effectType, _isCrit);
    }

    // Virtual functions
    protected override void OnDamage(float dmg, bool ignoreImmunity = false, bool grantImmunity = true, bool ignoreResistance = false, EffectType type = EffectType.None, bool _isCrit = false)
    {
        // Grant player 0.1 second of immunity after being hit
        if (grantImmunity) Protect(0.1f);

        // Update achievement flags
        playerHitInLevel = true;
        playerHitInRoom = true;

        // Play hurt sound
        PlayAudio(damageAudio);

        // Visual damage flash cue
        CameraDamageEffect.instance.ActivateFlash();
    }
    protected override void Die()
    {
        //Change this to use SceneControl
        transform.position = new Vector3(0, -300, 0);

        //gameObject.GetComponent<Collider>().enabled = false;
        FreezeGameplayInput(true);
        //rb.isKinematic = false;
        GameManager.GMinstance.GameScore = score;
        GameManager.GMinstance.OnLose();

        this.BYLEBoosted = false;
        this.isPoisoned = false;
        //SceneControl.OnLose();
    }
    public override void BYLEInteraction()
    {
        //Debug.Log("Player Affected by BYLE");
        //if(PLayer has certain gun, do other stuff)

        //otherwise poison them
        if (this.isPoisoned != true)
        {
            //instance.Poison(5.0f, 2.0f, -0.4f);
            BYLEBoosted = false;
        }

        //if(this.isPoisoned && this.BYLEBoosted)
        //{
        //    BYLEBoosted = false;
        //}
    }

    // Public functions
    public void FreezeGameplayInput(bool freeze)
    {
        freezeGameplayInputs = freeze;
        //rb.isKinematic = freeze;
        rb.velocity = new Vector3(0, 0, 0);
        //CameraController.instance.SetCameraLocked(freeze);
    }

    // Check if the player currently has all their gameplay inputs frozen
    public bool GetFreezeGameplayInput()
    {
        return freezeGameplayInputs;
    }

    // Get the ratio of current health and max health
    public float GetHealthRatio()
    {
        return health / maxHealth;
    }

    // Gets the current percentage left on the roll cooldown timer
    public float GetRollCooldown()
    {
        return rollCooldownTimer / rollCooldownLength;
    }

    // Used to update the players current coin count
    public void ChangeCoinValue(int val)
    {
        coins += val;
        if (val > 0)
        {
            GameManager.GMinstance.coinsCollected += val;
            GameManager.GMinstance.IncrementSteamStatsForAchievements("Coins", val);
        }
        if (coins < 0) { coins = 0; }
        CoinCounter.instance.UpdateUI(coins);
    }

    // Checks what direction the player is moving in
    public Vector3 GetPlayerMoveDirection() { return directionOfMovement; }

    // Returns the players current coin count
    public int GetCoinValue()
    {
        return coins;
    }

    // Gets the current mouse position
    public Vector3 GetMousePos()
    {
        var ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        if (Physics.Raycast(ray, out var hitInfo, Mathf.Infinity, 1 << 6))
        {
            return hitInfo.point;
        }
        else
        {
            return Vector3.zero;
        }
    }

    // Gets the players current movement direction relative to the players current aim
    public PlayerMoveDirection GetMovementDirection() // Returns a value equivalent to left, right, up, down or none depending on which direction the player is moving relative to their aim
    {
        //Get the movement vector of the player
        //Dot product comparison of Tranform direction
        //Pick highest dot product
        Vector3 playerVelocity = new Vector3(Input.GetAxisRaw("MoveH"), 0, Input.GetAxisRaw("MoveV"));
        if(playerVelocity == Vector3.zero)
        {
            return PlayerMoveDirection.None;
        }
        playerVelocity.Normalize();
        Vector3 closestDirection = Vector3.zero;
        Vector3[] temp = new Vector3[4]; // Array containing all 4 directions
        temp[0] = transform.forward;
        temp[1] = -transform.forward;
        temp[2] = transform.right;
        temp[3] = -transform.right;
        
        // Dot product between the players current movement and all 4 directions
        float score, highscore =-100;
        foreach(Vector3 direction in temp)
        {
            score = Vector3.Dot(playerVelocity,direction);
            if(score > highscore)
            {
                highscore = score;
                closestDirection = direction;
            }
        }

        // WHichever direction had most resembled the players current move velocity then return the enumerator that is equivalent of that direction
        if(closestDirection == temp[0])
        {
            return PlayerMoveDirection.Forwards;
        }
        else if(closestDirection == temp[1])
        {
            return PlayerMoveDirection.Backwards;
        }
        else if(closestDirection == temp[2])
        {
            return PlayerMoveDirection.Right;
        }
        else
        {
            return PlayerMoveDirection.Left;
        }
    }

    // Gets the players current roll charge count
    public int GetRollCharges()
    {
        return rollCharges;
    }

    // Gets a reference to the players current active powerup
    public BaseActivePowerup GetAbility()
    {
        return currentAbility;
    }

    // Gets the current remaining time left on the active ability cooldown
    public float GetAbilityCooldownTime()
    {
        return abilityTimer;
    }

    // Puts the ability cooldown back to it's max value
    public void RestartAbilityCooldown()
    {
        abilityTimer = currentAbility.GetCooldownTime();
    }

    // Returns true if the player is rolling
    public bool IsRolling()
    {
        return isRolling;
    }

    // Sets the player character so that they have the matching abilties and modifiers of the characters on the main screen
    public void SetPlayerCharacter()
    {
        //Remove any existing character decor
        //if (decor.GetChild(0) != null) Destroy(decor.GetChild(0).gameObject);

        //Add character decor
        GameObject decorObject = null;
        GameObject characterAbility = null;
        List<Modifier> characterMods = new List<Modifier>();

        // Get current character and assign modifiers and abilities
        currCharacter = GameManager.GMinstance.selectedCharacter;
        switch (currCharacter)
        {
            case SelectedCharacter.VLAD:
                decorObject = Instantiate(Resources.Load("CharacterDecor/Vlad") as GameObject, decor);
                characterAbility = Instantiate(Resources.Load("CharacterDecor/VladMolotov") as GameObject);
                characterMods.Add(new Modifier(ModifierType.ExtraCoinChance, 0.1f));
                break;
            case SelectedCharacter.MIKE:
                decorObject = Instantiate(Resources.Load("CharacterDecor/Mike") as GameObject, decor);
                characterMods.Add(new Modifier(ModifierType.MaxHealth, 50.0f));
                characterMods.Add(new Modifier(ModifierType.ClipSize, 0.5f));
                break;
            case SelectedCharacter.OL_ONE_EYE:
                decorObject = Instantiate(Resources.Load("CharacterDecor/OneEye") as GameObject, decor);
                characterMods.Add(new Modifier(ModifierType.ReloadTime, 0.25f));
                characterMods.Add(new Modifier(ModifierType.CritChance, 0.15f));
                break;
            case SelectedCharacter.DART:
                decorObject = Instantiate(Resources.Load("CharacterDecor/Dart") as GameObject, decor);
                characterAbility = Instantiate(Resources.Load("CharacterDecor/DartPills") as GameObject);
                characterMods.Add(new Modifier(ModifierType.RollCharges, 1));
                break;
            case SelectedCharacter.KARLOS:
                decorObject = Instantiate(Resources.Load("CharacterDecor/Karlos") as GameObject, decor);
                characterMods.Add(new Modifier(ModifierType.Damage, 0.25f));
                characterMods.Add(new Modifier(ModifierType.Pierce, 1.0f));
                break;
            case SelectedCharacter.XERXES:
                decorObject = Instantiate(Resources.Load("CharacterDecor/Xerxes") as GameObject, decor);
                characterMods.Add(new Modifier(ModifierType.MaxHealth, -99.0f));
                characterMods.Add(new Modifier(ModifierType.Damage, 0.3333f));
                characterMods.Add(new Modifier(ModifierType.Speed, 0.5f));
                characterMods.Add(new Modifier(ModifierType.RollCharges, 2.0f));
                break;
            case SelectedCharacter.KYLE:
                decorObject = Instantiate(Resources.Load("CharacterDecor/Kyle") as GameObject, decor);
                characterMods.Add(new Modifier(ModifierType.ClipSize, 0.5f));
                characterMods.Add(new Modifier(ModifierType.CooldownReduction, 0.25f));
                characterMods.Add(new Modifier(ModifierType.CritChance, 0.25f));
                characterMods.Add(new Modifier(ModifierType.Damage, 0.25f));
                characterMods.Add(new Modifier(ModifierType.Discount, 0.25f));
                characterMods.Add(new Modifier(ModifierType.MaxHealth, 20.0f));
                characterMods.Add(new Modifier(ModifierType.Pierce, 1.0f));
                characterMods.Add(new Modifier(ModifierType.ProjectileSpeed, 0.25f));
                characterMods.Add(new Modifier(ModifierType.RateOfFire, 0.25f));
                characterMods.Add(new Modifier(ModifierType.ReloadTime, 0.25f));
                characterMods.Add(new Modifier(ModifierType.Speed, 0.25f));
                characterMods.Add(new Modifier(ModifierType.Vampirism, 0.02f));
                characterMods.Add(new Modifier(ModifierType.RollCharges, 2.0f));
                break;

            default: // If character somehow fails then default to Rambo's abilties
            case SelectedCharacter.RAMBO:
                decorObject = Instantiate(Resources.Load("CharacterDecor/Rambo") as GameObject, decor);
                characterMods.Add(new Modifier(ModifierType.Speed, 0.25f));
                characterMods.Add(new Modifier(ModifierType.ProjectileSpeed, 0.25f));
                break;
        }

        // Give special abilities on first level
        if (PlayerController.instance != null && GameManager.GMinstance.level == 1)
        {
            if (characterAbility == null) characterAbility = Instantiate(Resources.Load("CharacterDecor/DefaultStim") as GameObject); // If no ability was assigned give the character health stims
            PickupAbility(characterAbility.GetComponent<BaseActivePowerup>()); // Equip the ability on the player

            Debug.Log("Added Modifiers because 1st level");
            foreach (Modifier modifier in characterMods) // Apply each modifier listed onto the plauer
            {
                AddModifier(modifier.type, modifier.value);
            }
        }
    }

#region WeaponCode
    // Pickup a given weapon
void PickupWeapon(BaseWeapon _droppedWeapon)
    {
        if(_droppedWeapon == null) { return; }

        // Play swap animation for the weapon
        if(_droppedWeapon.GetSwapAnimName() != "")
        {
            animator.Play(_droppedWeapon.GetSwapAnimName());
        }
        else // Play pistol anim if missing
        {
            animator.Play("PistolSwap");
        }

        if (primaryWeapon == null && secondaryWeapon == null)
        {
            //No weapons, so add the weapon and put it in the primary slot
            //add weawpon
            primaryWeapon = _droppedWeapon;
            _droppedWeapon.OnPickup();
            //Put it in slot
            _droppedWeapon.transform.parent = weaponParent;
            _droppedWeapon.transform.position = weaponParent.position;
            _droppedWeapon.transform.rotation = weaponParent.rotation;
        }
        else if (primaryWeapon != null && secondaryWeapon == null)
        {
            //One weapon
            //add the weapon and put it in the primary slot
            //and move the current weapon to the secondary slot

            //Move weapon references
            secondaryWeapon = primaryWeapon;
            primaryWeapon = _droppedWeapon;
            primaryWeapon.OnPickup();
            //Move old weapon to secondary slot
            secondaryWeapon.transform.parent = secondaryParent;
            secondaryWeapon.transform.position = secondaryParent.position;
            secondaryWeapon.transform.rotation = secondaryParent.rotation;
            secondaryWeapon.OnStow();
            //Move new weapon to primary slot
            primaryWeapon.transform.position = weaponParent.position;
            primaryWeapon.transform.parent = weaponParent;
            _droppedWeapon.transform.rotation = weaponParent.rotation;
        }
        else if (primaryWeapon != null && secondaryWeapon != null)
        {
            //Two weapons
            //Equip new weapon in primary slot, and drop curr primary weapon

            //Remove primary weapon
            primaryWeapon.OnDrop();
            //Set new weapon
            primaryWeapon = _droppedWeapon;
            primaryWeapon.OnPickup();
            //Set pos
            primaryWeapon.transform.position = weaponParent.position;
            primaryWeapon.transform.parent = weaponParent;
            _droppedWeapon.transform.rotation = weaponParent.rotation;
        }
        else
        {
            Debug.Log("wtf");
        }

    }

    // Checks for any weapon inputs
    void UpdateWeapon()
    {
        //Check for inputs
        if(primaryWeapon == null) { return; }
        //Mouse0
        if (!isRolling && weaponSwapTime + 0.4f <= Time.unscaledTime)
        {
            if (Input.GetMouseButton(0) || Input.GetAxisRaw("Fire1") > 0)
            {
                primaryWeapon.OnFireOneHeld();
            }
            if (Input.GetMouseButtonDown(0))
            {
                primaryWeapon.OnFireOneDown();
            }
            if (Input.GetMouseButtonUp(0))
            {
                primaryWeapon.OnFireOneUp();
            }
            //Mouse1
            if (Input.GetMouseButton(1) || Input.GetAxisRaw("Fire2") > 0)
            {
                primaryWeapon.OnFireTwoHeld();
            }
            if (Input.GetMouseButtonDown(1))
            {
                primaryWeapon.OnFireTwoDown();
            }
            if (Input.GetMouseButtonUp(1))
            {
                primaryWeapon.OnFireTwoUp();
            }
            //Reload
            if (Input.GetButton("Reload"))
            {
                primaryWeapon.OnReloadHeld();
            }
            if (Input.GetButtonDown("Reload"))
            {
                primaryWeapon.OnReloadDown();
            }
            if (Input.GetButtonUp("Reload"))
            {
                primaryWeapon.OnReloadUp();
            }
        }
    }

    // Switches between the 2 equipped weapons
    void SwitchWeapon()
    {
        if (secondaryWeapon == null) { return; }

        // Cannot rapidly scroll between weapons
        if (scrollTimer > 0)
        {
            scrollTimer -= Time.unscaledDeltaTime;
            return;
        }
        if (Input.mouseScrollDelta.y == 0)
        {
            return;
        }
        scrollTimer = 0.1f;

        //Swap references to the weapons
        Debug.Log("Weapon swapped");
        BaseWeapon temp = primaryWeapon;
        primaryWeapon = secondaryWeapon;
        secondaryWeapon = temp;

        //Swap positions
        primaryWeapon.transform.parent = weaponParent;
        primaryWeapon.transform.position = weaponParent.transform.position;
        primaryWeapon.transform.rotation = weaponParent.transform.rotation;

        secondaryWeapon.transform.parent = secondaryParent;
        secondaryWeapon.transform.position = secondaryParent.transform.position;
        secondaryWeapon.transform.rotation = secondaryParent.transform.rotation;

        // Equipd and stow the weapons
        primaryWeapon.OnEquip();
        secondaryWeapon.OnStow();

        // Play weapon swap animations
        animator.speed = 1;
        string animName = primaryWeapon.GetSwapAnimName();
        if(animName == null)
        {
            animator.Play("PistolSwap");
        }
        else
        {
            animator.Play(animName);
        }

        // Reset timer
        weaponSwapTime = Time.unscaledTime;
    }

    // Set the main weapon on the player. Used by game manager
    public void SetMainWeapon(GameObject weapon)
    {
        if(weapon.TryGetComponent<BaseWeapon>(out BaseWeapon newWeapon))
        {
            if(primaryWeapon != null)
            {
                //Delete the current primary weapon
                Destroy(primaryWeapon.gameObject);
            }

            //Set the new weapon to the primary weapon
            primaryWeapon = newWeapon;
            primaryWeapon.OnPickup();
                
            //Put new weapon into slot
            primaryWeapon.transform.parent = weaponParent;
            primaryWeapon.transform.position = weaponParent.position;
            primaryWeapon.transform.rotation = weaponParent.rotation;
        }
    }
    // Same as above but for secondary weapon
    public void SetSecondaryWeapon(GameObject weapon)
    {
        if(weapon.TryGetComponent<BaseWeapon>(out BaseWeapon newWeapon))
        {
            if(secondaryWeapon != null)
            {
                //Delete the current primary weapon
                Destroy(secondaryWeapon.gameObject);
            }
            
            //Set the new weapon to the primary weapon
            secondaryWeapon = newWeapon;
            secondaryWeapon.OnPickup();
                
            //Put new weapon into slot
            secondaryWeapon.transform.parent = secondaryParent;
            secondaryWeapon.transform.position = secondaryParent.position;
            secondaryWeapon.transform.rotation = secondaryParent.rotation;
        }
    }

    // Get the sprite of the main weapon for the HUD
    public Sprite GetMainWeaponSprite()
    {
        return primaryWeapon.weaponSprite;
    }

    // Returns the main / secondary weapon reference
    public BaseWeapon GetMainWeapon()
    {
        return primaryWeapon;
    }
    public BaseWeapon GetSecondaryWeapon()
    {
        return secondaryWeapon;
    }

    // Enables or disabled the ability to fire weapons
    public void EnableWeapons(bool a_enabled)
    {
        canUseWeapons = a_enabled;
    }
    #endregion

    // Resets the players animation state
    public void ResetPlayerAnimationState()
    {
        animator = this.GetComponent<Animator>(); // Get animator
        
        // Reset primarys collider and state and start idle anim
        if(primaryWeapon != null)
        {
            primaryWeapon.GetComponent<Collider>().enabled = false;
            primaryWeapon.GetComponent<BaseWeapon>().currState = BaseWeapon.WeaponState.EQUIPPED;
            animator.Play(primaryWeapon.GetIdleAnimName());
        }
        // Disable secondarys collider and stow it
        if(secondaryWeapon != null)
        {
            secondaryWeapon.GetComponent<Collider>().enabled = false;
            secondaryWeapon.OnStow();
        }
    }

    void OnDrawGizmos()
    {
        //Draw aim pos
        if(aimPos == null){return;}
        Gizmos.DrawWireCube(aimPos,Vector3.one * 0.5f);
        Gizmos.DrawLine(transform.position, aimPos);
    }

}

public enum PlayerMoveDirection
{
    Forwards,
    Backwards,
    Left,
    Right,
    None
}
</code></pre>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div class = "dropdown">
                                    <button class="dropdown__button">
                                        Weapons
                                    </button>
        
                                    <div class = "dropdown__content">
                                        <div class ="dropdown__text">
                                            Dropdowns All
                                        </div>
                                    </div>
                                </div>

                                <div class = "dropdown">
                                    <button class="dropdown__button">
                                        Powerups/Modifiers
                                    </button>
        
                                    <div class = "dropdown__content">
                                        <div class ="dropdown__text">
                                            Together Don't mess up things!
                                        </div>
                                    </div>
                                </div>

                                <div class = "dropdown__text">
                                    Ontop of this I assited in the creation of various enemy behaviours, level generation, achievement management and sound systems implemented in the game.
                                </div>
                            </div>
                        </div>
                    </p>
                </div>
            </div>
        </div>
    </section>
    <script src="app.js"></script>
</body>
</html>