<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reese Programs A Thing</title>
    <link rel="stylesheet" href="ProjectPageStyles.css">
    <script src="https://kit.fontawesome.com/650c1785fc.js" crossorigin="anonymous"></script>
</head>
<body>
    <section id="top"></section>

    <!--Nav Bar Section-->
    <nav class="navbar">
        <div class="navbar__container">
            <a href="/index.html" id="navbar__logo">Reese Todhunter</a>
            <div class="navbar__toggle" id="mobile-menu">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="back"></span>
            </div>
            <ul class="navbar__menu">
                <li class="navbar__btn">
                    <a href="/index.html#about" class="button navred"><i class="fa-solid fa-circle-info"></i>About</a>
                </li>
                <li class="navbar__btn">
                    <a href="/index.html#projects" class="button navgreen"><i class="fa-solid fa-laptop-code"></i>Projects</a>
                </li>
                <li class="navbar__btn">
                    <a href="/index.html#gamejams" class="button navblue"><i class="fa-solid fa-laptop-code"></i>GameJams</a>
                </li>
                <li class="navbar__btn">
                    <a href="/pdf/Reese_Todhunter-CV.pdf" target="_blank" class="button navorange"><i class="fa-solid fa-file-lines"></i>CV</a>
                </li>
                <li class="navbar__btn">
                    <a href="/index.html#contact" class="button navyellow"><i class="fa-solid fa-message"></i>Contact</a>
                </li>
            </ul>
        </div>
    </nav>

    <section class="project">
        <div class="project">
            <div class="project__title">
                <h1>Byle</h1>
            </div>
            <div class="project__background" style = "background-color: #0e5210;">
                <div class="video__wrapper">
                    <video src="videos/Byle Trailer.mp4" alt="video" id="main__video"
                     style = "width: 100%; height: 100%;" controls poster = "images/Byle Thumbnail.png"></video>
                </div>
                    <p><br/>
                        BYLE was built as a final year group project at <a href = "https://www.glos.ac.uk/" target="_blank">The University of Gloucestershire</a>.<br/>
                        I worked on this project alongside 4 other programmers and 2 designers to build this in C#
                        The game has 2 complete gamemodes, an infinitely looping rogue-like, 
                        where the player is tasked with fighting their way through corrrupted city full of varied enemies and bosses.
                        Alongside a colosseum mode, in which the player fights through premade waves of enemies, with unique bosses every 10 waves up to wave 100.<br/>
                        <a href = "https://store.steampowered.com/app/2517000/BYLE/" target="_blank">We also worked to put the game on Steam where it is now available!</a><br/><br/>
                        
                        <div class = "dropdown">
                            <button class="dropdown__button green">
                                Main Contributions
                            </button>

                            <div class = "dropdown__content">
                                <div class ="dropdown__text">
                                    My main contributions to the project were the player controller, weapon code, powerup/modifer systems, and steam integration.<br/>
                                </div>

                                <div class = "dropdown">
                                    <button class="dropdown__button green">
                                        Player Controller
                                    </button>
        
                                    <div class = "dropdown__content">
                                        <div class = "dropdown__text">
                                            The player controller is built to function as a top down character with multiple weapon and powerup 
                                            capabilities which can be swapped out and changed at run time.<br/>
                                            The controller inherits from a "Character" base class, which holds the base methods for things such as: Healing, Taking Damage, Death and Status Effects. <br/>
                                            Along side all of their repective variables.<br/>
                                            Both the "Character" and the "PlayerController" code can be found within the below dropdowns.<br/>
                                        </div>
                                        <div class = "dropdown">
                                            <button class = "dropdown__button lightblue" style = "scale: 80%;">
                                                Character Code
                                            </button>
                                            <div class = "dropdown__content">
                                                <div class = "dropdown__codeblock">
<pre><code class="language-csharp">
    public class Character : MonoBehaviour
    {
        public int characterID;
        // Button above player that can be used to display a debug message
        // Off by default in hierarchy
        [SerializeField] public Text debugButton;
    
        // Character Stats
        [SerializeField] protected float baseMaxHealth; // Max health before modifiers
        protected float maxHealth; // Max health after modifiers
        protected float health = 0.0f; // Current health of character
    
        // Speed
        [SerializeField] float speedDefault = 0.0f; // Speed value without any modifiers attached
        protected float speed = 0.0f; // Speed of character after modifiers
    
        // Immunity
        [SerializeField] GameObject immuneIndicator;
        protected bool isInvulnerable = false; // True if the character is currently immune to all damage
        float invulnerableTimer = 0.0f; // How long the character is invulnerable for
    
        // Status Effects
        // General
        List<StatusEffect> statusEffects = new List<StatusEffect>(); // List of every status effect on the character
        List<GameObject> statusIndicators = new List<GameObject>(); // Currently active indicators indicating the characters statuses. Indication.
        // Burn
        [SerializeField] GameObject burnIndicator;
        bool isBurning = false;
        // Poison
        [SerializeField] GameObject poisonIndicator;
        protected bool isPoisoned = false;
        protected bool isStunned = false;
        // Byle
        [SerializeField]
        public bool BYLEBoosted = false;
        //Score
        public int score = 0;
    
        // Attributes / Modifiers
        List<Modifier> modifiers = new List<Modifier>(); // Modifiers
    
        //Particle Effects
        private GameObject burnVFX;
        private GameObject stunVFX;
        private GameObject poisonVFX;
    
    
        // HEALTH
        public virtual void Damage(float dmg, bool ignoreImmunity = false, bool grantImmunity = true, bool ignoreResistance = false, EffectType _effectType = EffectType.None, bool _isCrit = false)
        {
            if(health > 0.0f)
            {
                if (!isInvulnerable || (isInvulnerable && ignoreImmunity))
                {
                    float damageTaken = 0.0f;
                    if (ignoreResistance)
                    {
                        damageTaken = Mathf.Max(0.0f, dmg);
                    }
                    else
                    {
                        damageTaken = Mathf.Max(0.0f, dmg * Mathf.Max(0.1f, (1.0f + GetModifier(ModifierType.Vulnerability))));
                    }
    
                    health -= damageTaken;
                    if (health <= 0.0f)
                    {
                        Die();
                    }
    
                    // TEMPORARY TEXT FOR DEBUGGING :))))
                    if (dmg != 0)
                    {
                        GameObject floatingText = Instantiate(ProjectileLibrary.instance.GetProjectile(Projectiles.FLOATING_TEXT), transform.position + Vector3.up * 1.5f + Vector3.one * Random.Range(-0.2f, 0.2f), Quaternion.Euler(Vector3.zero));
                        floatingText.GetComponent<ItemPickupFade>().SetText((Mathf.Round(damageTaken*10.0f)/10.0f).ToString(), _effectType, _isCrit);
                    }
    
                    OnDamage(damageTaken, ignoreImmunity, grantImmunity, ignoreResistance, _effectType,_isCrit);
                }
            }
            
    
            // Check if dead
            //Maybe Remove this later?
            if (health <= 0.0f && !isInvulnerable)
            {
                Die();
            }
        }
        public float Heal(float heal)
        {
            float oldHealth = health;
    
            health += Mathf.Max(0.0f, heal);
            health = Mathf.Min(health, maxHealth); // Making sure health didn't go over cap
            OnHeal(heal);
            
            if (CameraDamageEffect.instance != null)
            {
                if (GetHealth()>GetMaxHealth()/2) CameraDamageEffect.instance.SetMinOpacity();
            }
            return health - oldHealth;
        }
        public virtual void OnHeal(float _heal){}
        public float GetHealth()
        {
            return health;
        }
        public float GetMaxHealth()
        {
            return maxHealth;
        }
        protected virtual void Die()
        {
            Destroy(gameObject);
        }
        protected virtual void OnDamage(float dmg, bool ignoreImmunity = false, bool grantImmunity = true, bool ignoreResistance = false, EffectType type = EffectType.None, bool _isCrit = false)
        {
            return;
        }
    
        // DAMAGE
        public virtual void OnDamageDealt(float dmg)
        {
            Heal(dmg * GetModifier(ModifierType.Vampirism));
        }
    
        // BYLE
        public virtual void BYLEInteraction()
        {
            //Override this in the player character and enemy scripts
            //For enemies, this may not work due to the behaviour tree
        }
    
        // INVULNERABILITY
        public void Protect(float time)
        {
            if (invulnerableTimer < time) { invulnerableTimer = time; }
            isInvulnerable = true;
            UpdateIndicator(immuneIndicator, true);
        }
        public bool IsInvulnerable()
        {
            return isInvulnerable;
        }
    
        // STATUS EFFECTS
        private void AddStatus(StatusType a_type, EffectType a_effect, float a_damage, float a_maxTime, float a_tickTime = 1.0f)
        {
            // Should not be called directly
            // Also do not add 2 status effects of the same "effect" type (except "None") and different lengths
            // This WILL mess up how the character knows what status effect it has
            // And it will be YOUR fault and definitely not mine
            // That being said if you want to improve it go ahead
            statusEffects.Add(new StatusEffect(a_type, a_effect, this, a_damage, a_maxTime, a_tickTime));
        }
        public void Burn(float time, float tickDmg)
        {
            // Check if the character is currently invulnerable to everything
            if (!isInvulnerable)
            {
                // Check if the character is already burning and determine if pre-existing burn should be overwritten
                if (isBurning)
                {
                    // Find the other matching status effect
                    List<StatusEffect> removedStatuses = new List<StatusEffect>();
                    foreach(StatusEffect effect in statusEffects)
                    {
                        if (effect != null && effect.MatchingStatus(StatusType.Damage, EffectType.Burn)) // Check for a damage & burn status
                        {
                            // Return early if time remaining on current burn is longer than new burn, so new burn is ignored
                            if (effect.TimeRemaining() >= time)
                            {
                                return;
                            }
    
                            removedStatuses.Add(effect); // Remove old status since it will now be replaced
                        }
                    }
                    // Clearing overwritten status effects from list
                    foreach (StatusEffect effect in removedStatuses)
                    {
                        statusEffects.Remove(effect);
                    }
                }
                
                // Apply status effect
                AddStatus(StatusType.Damage, EffectType.Burn, tickDmg, time, 0.5f); // MAGIC NUMBER (tick time)
    
                // Other values
                isBurning = true;
                UpdateIndicator(burnIndicator, true);
            }
        }
        public bool IsBurning()
        {
            return isBurning;
        }
        public void Poison(float time, float tickDmg, float speedMultiplier)
        {
            if (!isInvulnerable)
            {
                // Check if the character is already burning and determine if pre-existing poison should be overwritten
                if (isPoisoned)
                {
                    // Find the other matching status effects
                    bool overwriteEffect = false;
                    List<StatusEffect> removedStatuses = new List<StatusEffect>();
                    foreach (StatusEffect effect in statusEffects)
                    {
                        if (effect != null && effect.GetEffectType() == EffectType.Poison)
                        {
                            // Return early if time remaining on current poison is longer than new poison, so new poison is ignored
                            // In theory there shouldn't be 2 different poison effects with different times
                            // If there is then this overwrite code is flawed and could potentially allow for stacked poison effects
                            // But that shouldn't happen as long as AddEffect() is used properly :)
                            if (!overwriteEffect && effect.TimeRemaining() >= time)
                            {
                                return;
                            }
                            else
                            {
                                overwriteEffect = true;
                                removedStatuses.Add(effect);
                            }
                        }
                    }
                    // Clearing overwritten status effects from list
                    foreach (StatusEffect effect in removedStatuses)
                    {
                        statusEffects.Remove(effect);
                    }
                }
    
                // Apply status effect
                AddStatus(StatusType.Damage, EffectType.Poison, tickDmg, time, 1.0f); // MAGIC NUMBER (tick time)
                AddStatus(StatusType.Speed, EffectType.Poison, speedMultiplier, time);
    
                // Other values
                isPoisoned = true;
                UpdateIndicator(poisonIndicator, true);
            }
        }
        public bool IsPoisoned()
        {
            return isPoisoned;
        }
        public virtual void Stun(float time)
        {
            if (!isInvulnerable)
            {
                // Check if the character is already burning and determine if pre-existing poison should be overwritten
                if (isStunned)
                {
                    // Find the other matching status effects
                    bool overwriteEffect = false;
                    List<StatusEffect> removedStatuses = new List<StatusEffect>();
                    foreach (StatusEffect effect in statusEffects)
                    {
                        if (effect != null && effect.GetEffectType() == EffectType.Stun)
                        {
                            // Return early if time remaining on current poison is longer than new poison, so new poison is ignored
                            // In theory there shouldn't be 2 different poison effects with different times
                            // If there is then this overwrite code is flawed and could potentially allow for stacked poison effects
                            // But that shouldn't happen as long as AddEffect() is used properly :)
                            if (!overwriteEffect && effect.TimeRemaining() >= time)
                            {
                                return;
                            }
                            else
                            {
                                overwriteEffect = true;
                                removedStatuses.Add(effect);
                            }
                        }
                    }
                    // Clearing overwritten status effects from list
                    foreach (StatusEffect effect in removedStatuses)
                    {
                        statusEffects.Remove(effect);
                    }
                }
    
                // Apply status effect
                AddStatus(StatusType.inputLocked, EffectType.Stun, 0, time, 1.0f); // MAGIC NUMBER (tick time)
                // Other values
                isStunned = true;
            }
        }
        public bool IsStunned()
        {
            return isStunned;
        }
        protected virtual void OnStunEnd()
        {
        }
        // ATTRIBUTE MODIFIERS
        public void AddModifier(ModifierType modType, float modAmount)
        {
            modifiers.Add(new Modifier(modType, modAmount));
    
            // Any other active effects caused by adding modifiers
            switch (modType)
            {
                case ModifierType.MaxHealth:
                    maxHealth = Mathf.Max(1.0f, baseMaxHealth + GetModifier(ModifierType.MaxHealth));
                    Heal(modAmount);
                    if (health > maxHealth) health = maxHealth; // Lower health if it is greater than the max
                    break;
            }
        }
        public float GetModifier(ModifierType modType)
        {
            float modTotal = 0.0f;
    
            // really cringe rate of fire specific multiplicative modifer thing
            if (modType == ModifierType.RateOfFire)
            {
                modTotal = 1.0f;
                foreach (Modifier modifier in modifiers)
                {
                    if (modifier.type == modType) modTotal *= 1-modifier.value;
                }
                return modTotal;
            }
    
            foreach (Modifier modifier in modifiers)
            {
                if (modifier.type == modType) modTotal += modifier.value;
            }
            
            return modTotal;
        }
        public void RemoveModifier(ModifierType modType, float modAmount)
        {
            // Attempt to find modifer keyvaluepair inside dictionary and remove it
            foreach (Modifier modifier in modifiers)
            {
                if (modifier.type == modType && modifier.value == modAmount)
                {
                    modifiers.Remove(modifier);
                    return;
                }
            }
    
            // Add negative modifier if item couldn't be removed
            Debug.LogWarning("MODIFIER OF TYPE: " + modType.ToString() + " AND VALUE: " + modAmount.ToString() + " COULD NOT BE REMOVED. ADDING NEGATIVE MODIFIER.");
            modifiers.Add(new Modifier(modType, -modAmount));
        }
        public List<Modifier> GetModifierList()
        {
            return modifiers;
        }
        // UTILITY
        protected void UpdateIndicator(GameObject indicator, bool enabled) // Used for updating status effect icons
        {
            if (indicator != null)
            {
                if (enabled && !statusIndicators.Contains(indicator))
                {
                    statusIndicators.Add(indicator);
                    indicator.SetActive(true);
                }
                else if (!enabled && statusIndicators.Contains(indicator))
                {
                    statusIndicators.Remove(indicator);
                    indicator.SetActive(false);
                }
            }
        }
    
        // CHARACTER UPDATES
        private void Awake()
        {
            CharacterAwake();
        }
        protected void CharacterAwake()
        {
            if(this.gameObject.GetComponent<BTAgent>() != null)
            {
                if (this.GetComponent<BTAgent>().enemyType == BTAgent.EnemyType.Boss)
                {
                    baseMaxHealth = baseMaxHealth + (Mathf.CeilToInt((baseMaxHealth / 2) * GameManager.GMinstance.healthDifficultyScale));
                }
                else
                {
                    Debug.Log("Enemies Health scaled with level");
                    baseMaxHealth = baseMaxHealth + (Mathf.CeilToInt((baseMaxHealth / 10) * GameManager.GMinstance.healthDifficultyScale));
                    Debug.Log(health);
                }
                
            }
            health = baseMaxHealth;
            speed = speedDefault;
    
    
            //init debuff effects
            burnVFX = GameObject.Instantiate(Resources.Load("VFX/Debuffs/Burn") as GameObject,Vector3.zero,Quaternion.identity);
            burnVFX.transform.parent = this.transform;
            burnVFX.transform.localPosition = Vector3.zero;
            burnVFX.gameObject.layer = transform.gameObject.layer;
    
            stunVFX = GameObject.Instantiate(Resources.Load("VFX/Debuffs/Stun") as GameObject,Vector3.zero,Quaternion.identity);
            stunVFX.transform.parent = this.transform;
            stunVFX.transform.localPosition = Vector3.zero;
            stunVFX.gameObject.layer = transform.gameObject.layer;
    
            poisonVFX = GameObject.Instantiate(Resources.Load("VFX/Debuffs/Poison") as GameObject,Vector3.zero,Quaternion.identity);
            poisonVFX.transform.parent = this.transform;
            poisonVFX.transform.localPosition = Vector3.zero;
            poisonVFX.gameObject.layer = transform.gameObject.layer;
        
        }
    
        private void Update()
        {
            CharacterUpdate(); 
        }
        protected void CharacterUpdate()
        {
            // HEALTH
            maxHealth = Mathf.Max(1.0f, baseMaxHealth + GetModifier(ModifierType.MaxHealth));
            if (health > maxHealth) health = maxHealth; // Lower health if it is greater than the max
    
            // INVULNERABILITY
            if (isInvulnerable)
            {
                invulnerableTimer -= Time.deltaTime;
                if (invulnerableTimer <= 0.0f)
                {
                    isInvulnerable = false;
                    UpdateIndicator(immuneIndicator, false);
                }
            }
    
            //status vfx update
            UpdateDebuffParticleSystem(burnVFX,isBurning);
            UpdateDebuffParticleSystem(poisonVFX,isPoisoned);
            UpdateDebuffParticleSystem(stunVFX,isStunned, true);
    
            //BYLE
            if (BYLEBoosted)
            {
                //Generic Override, implement individual interactions in the character scripts
                BYLEInteraction();
                //Make sure every BYLEInteraction override has a flag to turn off BYLE Boost
                //BYLEBoosted = false;
            }
    
            // STATUS EFFECTS
            // Resetting speed modifier, as it will be changed by the following status effects (if any)
            List<StatusEffect> removedStatuses = new List<StatusEffect>();
            // Updating each status effect
            foreach (StatusEffect effect in statusEffects)
            {
                if (effect == null) {
                    removedStatuses.Add(effect);
                    continue;
                }
    
                effect.Update();
    
                if (effect.IsOver())
                {
                    switch (effect.GetEffectType()) {
                        case EffectType.Burn:
                            isBurning = false;
                            UpdateIndicator(burnIndicator, false);
                            break;
                        case EffectType.Poison:
                            isPoisoned = false;
                            UpdateIndicator(poisonIndicator, false);
                            break;
                        case EffectType.Stun:
                            isStunned = false;
                            break;
                    }
                    removedStatuses.Add(effect);
                    continue;
                }
            }
            // Clearing all finished status effects from list
            foreach (StatusEffect effect in removedStatuses)
            {
                statusEffects.Remove(effect);
                if(effect.GetEffectType() == EffectType.Stun){OnStunEnd();}
            }
            // Updating UI for status effects
            for (int i = 0; i < statusIndicators.Count; ++i)
            {
                GameObject indicator = statusIndicators[i];
                float width = indicator.GetComponent<RectTransform>().sizeDelta.x; // Width of the indicator icon. If the size of these aren't all equal this will probably break
                float spacing = 55.0f;
    
                // Calculates the position of that indicator so all that are active on the character are centred nicely
                indicator.transform.localPosition = new Vector3(spacing*i - 0.5f*(statusIndicators.Count-1)*spacing, indicator.transform.localPosition.y, indicator.transform.localPosition.z);
            }
    
            // Updating for the characters new speed with modifiers applied
            speed = speedDefault * Mathf.Max(0.0f, 1.0f + GetModifier(ModifierType.Speed));
        }
        private void UpdateDebuffParticleSystem(GameObject pSystem, bool _debuffState, bool _clearParticles = false)
        {
            if(!_debuffState)
            {
                pSystem.GetComponent<ParticleSystem>().Stop();
                if(_clearParticles){pSystem.GetComponent<ParticleSystem>().Clear();}
                return;
            }
            if(pSystem.GetComponent<ParticleSystem>().isPlaying){return;}
            pSystem.GetComponent<ParticleSystem>().Play();
        }
    }
    
    
    public class Modifier
    {
        public Modifier(ModifierType type, float value)
        {
            this.type = type;
            this.value = value;
        }
    
        public ModifierType type { get; set; }
        public float value { get; set; }
    }
    
    // Different types of modifiers that the character can have changed against it
    public enum ModifierType
    {
        Accuracy,
        Damage,
        MaxHealth,
        RateOfFire,
        Speed,
        Vulnerability,
        ProjectileSpeed,
        ProjectileSize,
        ReloadTime,
        ReloadForgiveness,
        ClipSize,
        Vampirism,
        DodgeRollRing,
        RollCharges,
        Pierce,
        CoinHeal,
        EnemyExplosion,
        CritChance,
        Discount,
        ExtraCoinChance,
        CooldownReduction
    }
</code></pre>
                                                </div>
                                            </div>
                                        </div>
                                        <div class = "dropdown">
                                            <button class = "dropdown__button lightblue" style = "scale: 80%;">
                                                Player Controller Code
                                            </button>
                                            <div class = "dropdown__content">
                                                <div class = "dropdown__codeblock">
<pre><code class="language-csharp">
public class PlayerController : Character
{
    HighScoreDisplay HighScoreDisplay;

    // General
    public static PlayerController instance;
    Rigidbody rb;
    private Animator animator;
    private int coins = 0;

    //Audio
    public List<AudioClip> damageAudio = null;    //Audio for taking a hit
    public List<AudioClip> pickupAudio = null;    //Item get sound effect
    public List<AudioClip> abilitySounds = null;

    // Movement
    bool freezeGameplayInputs = false; // Set to true to stop player from
    Vector3 previousMousePos;

    // Dodge Roll
    public GameObject rollIndicator;
    public float rollSpeed; // How fast the player will roll
    public float rollLength; // How long a roll will last in seconds
    public float rollCooldownLength; // Time between each roll in seconds
    float rollTimer;
    float rollCooldownTimer;
    int rollCharges; // Amount of rolls the player currently has
    Vector3 rollDirection; // Direction of the roll

    // Active Ability
    public BaseActivePowerup currentAbility;
    float abilityTimer = 0.0f;

    // Weapon Fire
    public BaseWeapon primaryWeapon;
    public BaseWeapon secondaryWeapon;
    public Transform weaponParent;
    public Transform secondaryParent;
    public Transform modelCentre;
    bool canUseWeapons = true;
    float weaponSwapTime = 0.0f; // Used to stop firing weapons immediately after swapping
    private float scrollTimer = 0; // Used to stop the player from swapping weapons extremely fast

    //Weapon Specials
    public int NumOfChicks;

    //Misc
    private Vector3 directionOfMovement = Vector3.zero;
    public GameObject model;
    private Vector3 aimPos;
    private bool isRolling = false;

    // Character classes
    public enum SelectedCharacter
    {
        VLAD,
        MIKE,
        RAMBO,
        OL_ONE_EYE,
        DART,
        KARLOS,
        XERXES,
        KYLE
    }
    public SelectedCharacter currCharacter = SelectedCharacter.RAMBO;
    public Transform decor;

    // Achievement flags
    public bool playerHitInRoom = false;
    public bool playerHitInLevel = false;

    private void Awake()
    {
        // Instance for the enemy AIs
        if (instance != null)
        {
            if (instance != this)
            {
                Destroy(this);
            }
        }
        instance = this;

        
        // Getting rigidbody component
        rb = GetComponent<Rigidbody>();
        if (rb == null)
        {
            Debug.LogError("You are stupid. Give the player a rigidbody.");
        }
        animator = this.GetComponent<Animator>();
        
        if(primaryWeapon != null)
        {
            primaryWeapon.GetComponent<Collider>().enabled = false;
            primaryWeapon.GetComponent<BaseWeapon>().currState = BaseWeapon.WeaponState.EQUIPPED;
            animator.Play(primaryWeapon.GetIdleAnimName());
        }
        if(secondaryWeapon != null)
        {
            secondaryWeapon.GetComponent<Collider>().enabled = false;
            secondaryWeapon.OnStow();
        }
        // Character awake code
        CharacterAwake();
        if(GameManager.GMinstance == null){return;}
        if (!GameManager.GMinstance.loadGame)
        {
            if (SceneManager.GetActiveScene().name == "BUILD")
            {
                SetPlayerCharacter();
            }
        }

    }
    private void Update()
    {
        CharacterUpdate(); // Inherited from character. Runs all character updates (status effects and other)
        if (!freezeGameplayInputs)
        {
            Movement(); // Runs the movement code for the player
            DodgeRoll(); // Checks if the player has dodge rolled and runs any dodge roll functionality
            ItemInteract(); // Checks if the player is picking up an item
            ActiveAbility(); // Activates any abilities the player uses

            // Weapons
            if (canUseWeapons && !isStunned)
            {
                UpdateWeapon(); // Attempts to fire weapons and any other functionality they may have
                SwitchWeapon(); // Attempts to switch weapons
            }
        }

        if (modelCentre != null) { ObstacleHidingScript.SetPlayerScreenPosition(transform); } // For showing player through objects
    }
    private void LateUpdate()
    {
        if(rollTimer > 0){return;} // If the player is rolling do not update aim
        if (!freezeGameplayInputs)
        {
            Aim(); // Updates the players current aim
        }
    }
    // Update Functions
    void Movement()
    {
        // ---------------------------------------------------------
        // MOVEMENT
        // ---------------------------------------------------------
        rb.velocity = new Vector3(0.0f, rb.velocity.y, 0.0f); // Reset velocity

        if (rollTimer <= 0.0f && (Input.GetAxisRaw("MoveH") != 0 || Input.GetAxisRaw("MoveV") != 0))
        {
            Vector3 direction = new Vector3(Input.GetAxisRaw("MoveH"), 0, Input.GetAxisRaw("MoveV"));
            direction.Normalize();
            directionOfMovement = direction;
            rb.velocity = direction * (speed / Time.timeScale);
            //Debug.Log("Direction: X:" + direction.x + " Z:" + direction.z + " | Velocity: X:" + rb.velocity.x + " Z:" + rb.velocity.z +" | Roll Timer:" + rollTimer);
        }
    }

    void DodgeRoll()
    {
        // ---------------------------------------------------------
        // DODGE ROLL
        // ---------------------------------------------------------
        // TO-DO:
        // � Better implementation for locking abilities during a roll

        // Start roll (User has pressed roll key and direction)
        if (Input.GetButtonDown("Roll") && rollCharges > 0 && (Input.GetAxisRaw("MoveH") != 0 || Input.GetAxisRaw("MoveV") != 0))
        {
            //Debug.Log("ROLL START!!!!");

            // Hide roll indicator if it is currently active
            rollIndicator.SetActive(false);

            // I-Frames
            Protect(rollLength);

            // Decrease roll charges
            rollCharges--;

            // Get roll direction
            rollDirection = new Vector3(Input.GetAxisRaw("MoveH"), 0, Input.GetAxisRaw("MoveV"));
            rollDirection.Normalize();

            // Start roll timer
            rollTimer = rollLength; // Start roll timer
            rollCooldownTimer = rollCooldownLength; // Start roll cooldown timer (starts when rollTimer hits 0)

            // ANIMATION
            // Setting speed the of the roll animation based off time of the roll set in inspector
            animator.speed = 1 / rollLength;
            // Freeze all rigidbody rotation (stops animation freaking out when rolling into wall)
            rb.constraints = RigidbodyConstraints.FreezeRotation;
            // Roll animation
            switch (GetMovementDirection())
            {
                case PlayerMoveDirection.Forwards:
                    animator.Play("RollForward");
                    break;
                case PlayerMoveDirection.Backwards:
                    animator.Play("RollBackward");
                    break;
                case PlayerMoveDirection.Left:
                    animator.Play("RollLeft");
                    break;
                case PlayerMoveDirection.Right:
                    animator.Play("RollRight");
                    break;
                default:
                    break;
            }

            // Fire bullet ring if player has said ability
            GameObject rollProjectile = ProjectileLibrary.instance.GetProjectile(Projectiles.GENERIC_PLAYER_BULLET);
            int rollBullets = (int)GetModifier(ModifierType.DodgeRollRing);
            if (rollBullets > 0 && rollProjectile != null)
            {
                float bulletAngle = 360.0f / rollBullets;
                for (int i = 0; i < rollBullets; ++i)
                {
                    Instantiate(rollProjectile, transform.position + Vector3.up, Quaternion.Euler(0, bulletAngle * i, 0)).GetComponent<Projectile>()
                        .Init(30.0f * (1.0f + GetModifier(ModifierType.ProjectileSpeed)), 0.0f, 3.0f, 1.0f * (1.0f + GetModifier(ModifierType.Damage)), this.gameObject)
                        .SetPierce((int)PlayerController.instance.GetModifier(ModifierType.Pierce), 1.0f)
                        .SetCrit(Random.Range(0,10) == 0, 1.25f);
                }
            }

            isRolling = true;
        }

        // During roll (Roll timer is counting down)
        if (rollTimer > 0.0f)
        {
            //transform.LookAt(transform.position - rollDirection); // Look in roll direction

            rb.velocity = rollDirection * rollSpeed * (1+GetModifier(ModifierType.Speed)) / Time.timeScale; // Move in roll direction

            rollTimer -= Time.unscaledDeltaTime; // Decrease roll timer
        }

        // End of the roll (Roll timer is finished and now cooldown timer is counting down)
        if (rollTimer <= 0.0f && rollCooldownTimer > 0.0f)
        {
            // Reset rigidbody constraints back to normal so player can walk properly into walls again
            rb.constraints = RigidbodyConstraints.FreezeRotationX | RigidbodyConstraints.FreezeRotationZ;

            // Decrease roll cooldown timer
            rollCooldownTimer -= Time.unscaledDeltaTime * (1.0f + GetModifier(ModifierType.CooldownReduction));

            // Update player canvas UI
            rollIndicator.SetActive(true);
            rollIndicator.GetComponent<Slider>().value = GetRollCooldown();
            if(isRolling)
            {
                animator.speed = 1;
                isRolling = false;
                if(primaryWeapon != null)
                {
                    animator.Play(primaryWeapon.GetIdleAnimName());
                }
            }
            
        }

        // End of roll cooldown and missing a roll charge (The roll cooldown has finished)
        if (rollCooldownTimer <= 0.0f && rollCharges < 1+GetModifier(ModifierType.RollCharges))
        {
            rollCharges++;

            if (rollCharges < 1 + GetModifier(ModifierType.RollCharges))
            {
                rollCooldownTimer = rollCooldownLength;
            }

            else
            {
                rollIndicator.SetActive(false);
            }
        }
    }

    void Aim()
    {
        //Check if the mouse has moved
        if (previousMousePos != Input.mousePosition)
        {
            // Create a ray at the mouses position on screen
            var ray = Camera.main.ScreenPointToRay(Input.mousePosition);

            // Cast the ray from the mouse position out into the scene if hitting the ground layer turning the model to face the collision point
            if (rollTimer <= 0.0f && Physics.Raycast(ray, out var hitInfo, Mathf.Infinity, 1 << 6))
            {
                transform.LookAt(new Vector3(hitInfo.point.x, transform.position.y, hitInfo.point.z - weaponParent.position.y));
                aimPos = new Vector3(hitInfo.point.x, transform.position.y, hitInfo.point.z - weaponParent.position.y);
            }
            previousMousePos = Input.mousePosition;
        }
        
        // Controller aim
        else if (rollTimer <= 0.0f && (Input.GetAxisRaw("AimH") != 0 || Input.GetAxisRaw("AimV") != 0))
        {
            Vector3 direction = new Vector3(Input.GetAxisRaw("AimH"), 0, Input.GetAxisRaw("AimV"));
            transform.LookAt(transform.position + direction);
            aimPos = transform.position + direction;
        }
    }

    void ItemInteract()
    {
        //Check if player trying to interact
        if (!Input.GetButtonDown("Interact"))
        {
            return;
        }

        // Get all objects nearby
        Collider[] cols = Physics.OverlapSphere(transform.position, 5);
        // Get the closest item to you
        int itemType = -1; // 0 = weapon, 1 = active powerup
        float closestDistance = 999.9f;
        BaseWeapon closestWeapon = null; ;
        BaseActivePowerup closestActivePowerup = null;

        // Iterate through each collider found in pick up range
        foreach (Collider col in cols)
        {
            if (closestDistance > Vector3.Distance(transform.position, col.transform.position))
            {
                // If the collider is a weapon and mark it as closest item if thats the case
                if (col.gameObject.TryGetComponent<BaseWeapon>(out BaseWeapon weapon))
                {
                    itemType = 0;
                    closestWeapon = weapon;
                    closestDistance = Vector3.Distance(transform.position, col.transform.position);
                }

                // Same as above but for abilities
                else if (col.gameObject.TryGetComponent<BaseActivePowerup>(out BaseActivePowerup activePowerup))
                {
                    if (activePowerup.IsEquipped()) continue; // Ignore abilities that are already equipped
                    itemType = 1;
                    closestActivePowerup = activePowerup;
                    closestDistance = Vector3.Distance(transform.position, col.transform.position);
                }
            }
        }

        // Pick up whatever item was found
        switch (itemType)
        {
            case 0:
                PickupWeapon(closestWeapon);
                break;
            case 1:
                PickupAbility(closestActivePowerup);
                break;
        }
    }

    // Picks up an active ability powerup
    public void PickupAbility(BaseActivePowerup a_ability)
    {
        // No current ability
        if (currentAbility == null)
        {
            // Equip ability
            currentAbility = a_ability;
            currentAbility.Equip();
        }

        // Already ability equipped
        else
        {
            // Equip new and unequip old ability
            BaseActivePowerup oldAbility = currentAbility;
            currentAbility = a_ability;

            currentAbility.Equip();
            oldAbility.Unequip();

            // If old ability was still on cooldown restart the cooldown timer for the new powerup
            // This prevents players from swapping between 2 powerups for no cooldown times
            if (abilityTimer > 0.0f)
            {
                abilityTimer = currentAbility.GetCooldownTime();
            }
        }
    }

    // Called to check if the player is using their active ability
    void ActiveAbility()
    {
        if (abilityTimer <= 0.0f) // If not on cooldown
        {
            if (!isRolling && currentAbility != null && Input.GetButtonDown("Ability")) // If the player is pressing the button
            {
                abilityTimer = currentAbility.UseAbility(); // Use ability

                PlayAudio(abilitySounds);

                // If timer is -1 it means that the ability can no longer be used
                if (abilityTimer == -1.0f) {
                    Destroy(currentAbility.gameObject);
                    currentAbility = null;
                }
            }
        }
        else
        {
            abilityTimer -= Time.unscaledDeltaTime * (1.0f + GetModifier(ModifierType.CooldownReduction)); // Reduce ability cooldown timer
        }
    }

    // Plays the sound cue for picking up items
    public void PlayItemPickup()
    {
        PlayAudio(pickupAudio);
    }

    // Plays a given audio clips
    private void PlayAudio(List<AudioClip> audioClips)
    {
        if (audioClips.Count > 0)
        {
            //Get the audio source component and check it's not already playing something
            if (gameObject.TryGetComponent(out AudioSource audioSource) && !audioSource.isPlaying)
            {
                //Play a random audio clip from the available clips
                audioSource.clip = audioClips[Random.Range(0, audioClips.Count)];
                //Randomise the audio pitch
                audioSource.pitch = Random.Range(0.8f, 1.2f);
                //Set Audio volume
                audioSource.volume = GameManager.GMinstance.FXVolume;
                //Play randomised audio
                audioSource.Play();
            }
        }
    }

    // Damages the player
    // All the override does is check for an achievement, actual functionality is the same as the character.
    public override void Damage(float dmg, bool ignoreImmunity = false, bool grantImmunity = true, bool ignoreResistance = false, EffectType _effectType = EffectType.None, bool _isCrit = false)
    {
        // Achievement 18 check
        if (isRolling && Time.timeScale != 1.0f)
        {
            AchievementSystem.UnlockAchievement(18);
            AchievementSystem.Init();
            SaveLoadSystem.instance.SaveAchievements();
            GameManager.GMinstance.UnlockSteamAchievement("The_Matrix");
        }

        base.Damage(dmg, ignoreImmunity, grantImmunity, ignoreResistance, _effectType, _isCrit);
    }

    // Virtual functions
    protected override void OnDamage(float dmg, bool ignoreImmunity = false, bool grantImmunity = true, bool ignoreResistance = false, EffectType type = EffectType.None, bool _isCrit = false)
    {
        // Grant player 0.1 second of immunity after being hit
        if (grantImmunity) Protect(0.1f);

        // Update achievement flags
        playerHitInLevel = true;
        playerHitInRoom = true;

        // Play hurt sound
        PlayAudio(damageAudio);

        // Visual damage flash cue
        CameraDamageEffect.instance.ActivateFlash();
    }
    protected override void Die()
    {
        //Change this to use SceneControl
        transform.position = new Vector3(0, -300, 0);

        //gameObject.GetComponent<Collider>().enabled = false;
        FreezeGameplayInput(true);
        //rb.isKinematic = false;
        GameManager.GMinstance.GameScore = score;
        GameManager.GMinstance.OnLose();

        this.BYLEBoosted = false;
        this.isPoisoned = false;
        //SceneControl.OnLose();
    }
    public override void BYLEInteraction()
    {
        //Debug.Log("Player Affected by BYLE");
        //if(PLayer has certain gun, do other stuff)

        //otherwise poison them
        if (this.isPoisoned != true)
        {
            //instance.Poison(5.0f, 2.0f, -0.4f);
            BYLEBoosted = false;
        }

        //if(this.isPoisoned && this.BYLEBoosted)
        //{
        //    BYLEBoosted = false;
        //}
    }

    // Public functions
    public void FreezeGameplayInput(bool freeze)
    {
        freezeGameplayInputs = freeze;
        //rb.isKinematic = freeze;
        rb.velocity = new Vector3(0, 0, 0);
        //CameraController.instance.SetCameraLocked(freeze);
    }

    // Check if the player currently has all their gameplay inputs frozen
    public bool GetFreezeGameplayInput()
    {
        return freezeGameplayInputs;
    }

    // Get the ratio of current health and max health
    public float GetHealthRatio()
    {
        return health / maxHealth;
    }

    // Gets the current percentage left on the roll cooldown timer
    public float GetRollCooldown()
    {
        return rollCooldownTimer / rollCooldownLength;
    }

    // Used to update the players current coin count
    public void ChangeCoinValue(int val)
    {
        coins += val;
        if (val > 0)
        {
            GameManager.GMinstance.coinsCollected += val;
            GameManager.GMinstance.IncrementSteamStatsForAchievements("Coins", val);
        }
        if (coins < 0) { coins = 0; }
        CoinCounter.instance.UpdateUI(coins);
    }

    // Checks what direction the player is moving in
    public Vector3 GetPlayerMoveDirection() { return directionOfMovement; }

    // Returns the players current coin count
    public int GetCoinValue()
    {
        return coins;
    }

    // Gets the current mouse position
    public Vector3 GetMousePos()
    {
        var ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        if (Physics.Raycast(ray, out var hitInfo, Mathf.Infinity, 1 << 6))
        {
            return hitInfo.point;
        }
        else
        {
            return Vector3.zero;
        }
    }

    // Gets the players current movement direction relative to the players current aim
    public PlayerMoveDirection GetMovementDirection() // Returns a value equivalent to left, right, up, down or none depending on which direction the player is moving relative to their aim
    {
        //Get the movement vector of the player
        //Dot product comparison of Tranform direction
        //Pick highest dot product
        Vector3 playerVelocity = new Vector3(Input.GetAxisRaw("MoveH"), 0, Input.GetAxisRaw("MoveV"));
        if(playerVelocity == Vector3.zero)
        {
            return PlayerMoveDirection.None;
        }
        playerVelocity.Normalize();
        Vector3 closestDirection = Vector3.zero;
        Vector3[] temp = new Vector3[4]; // Array containing all 4 directions
        temp[0] = transform.forward;
        temp[1] = -transform.forward;
        temp[2] = transform.right;
        temp[3] = -transform.right;
        
        // Dot product between the players current movement and all 4 directions
        float score, highscore =-100;
        foreach(Vector3 direction in temp)
        {
            score = Vector3.Dot(playerVelocity,direction);
            if(score > highscore)
            {
                highscore = score;
                closestDirection = direction;
            }
        }

        // WHichever direction had most resembled the players current move velocity then return the enumerator that is equivalent of that direction
        if(closestDirection == temp[0])
        {
            return PlayerMoveDirection.Forwards;
        }
        else if(closestDirection == temp[1])
        {
            return PlayerMoveDirection.Backwards;
        }
        else if(closestDirection == temp[2])
        {
            return PlayerMoveDirection.Right;
        }
        else
        {
            return PlayerMoveDirection.Left;
        }
    }

    // Gets the players current roll charge count
    public int GetRollCharges()
    {
        return rollCharges;
    }

    // Gets a reference to the players current active powerup
    public BaseActivePowerup GetAbility()
    {
        return currentAbility;
    }

    // Gets the current remaining time left on the active ability cooldown
    public float GetAbilityCooldownTime()
    {
        return abilityTimer;
    }

    // Puts the ability cooldown back to it's max value
    public void RestartAbilityCooldown()
    {
        abilityTimer = currentAbility.GetCooldownTime();
    }

    // Returns true if the player is rolling
    public bool IsRolling()
    {
        return isRolling;
    }

    // Sets the player character so that they have the matching abilties and modifiers of the characters on the main screen
    public void SetPlayerCharacter()
    {
        //Remove any existing character decor
        //if (decor.GetChild(0) != null) Destroy(decor.GetChild(0).gameObject);

        //Add character decor
        GameObject decorObject = null;
        GameObject characterAbility = null;
        List<Modifier> characterMods = new List<Modifier>();

        // Get current character and assign modifiers and abilities
        currCharacter = GameManager.GMinstance.selectedCharacter;
        switch (currCharacter)
        {
            case SelectedCharacter.VLAD:
                decorObject = Instantiate(Resources.Load("CharacterDecor/Vlad") as GameObject, decor);
                characterAbility = Instantiate(Resources.Load("CharacterDecor/VladMolotov") as GameObject);
                characterMods.Add(new Modifier(ModifierType.ExtraCoinChance, 0.1f));
                break;
            case SelectedCharacter.MIKE:
                decorObject = Instantiate(Resources.Load("CharacterDecor/Mike") as GameObject, decor);
                characterMods.Add(new Modifier(ModifierType.MaxHealth, 50.0f));
                characterMods.Add(new Modifier(ModifierType.ClipSize, 0.5f));
                break;
            case SelectedCharacter.OL_ONE_EYE:
                decorObject = Instantiate(Resources.Load("CharacterDecor/OneEye") as GameObject, decor);
                characterMods.Add(new Modifier(ModifierType.ReloadTime, 0.25f));
                characterMods.Add(new Modifier(ModifierType.CritChance, 0.15f));
                break;
            case SelectedCharacter.DART:
                decorObject = Instantiate(Resources.Load("CharacterDecor/Dart") as GameObject, decor);
                characterAbility = Instantiate(Resources.Load("CharacterDecor/DartPills") as GameObject);
                characterMods.Add(new Modifier(ModifierType.RollCharges, 1));
                break;
            case SelectedCharacter.KARLOS:
                decorObject = Instantiate(Resources.Load("CharacterDecor/Karlos") as GameObject, decor);
                characterMods.Add(new Modifier(ModifierType.Damage, 0.25f));
                characterMods.Add(new Modifier(ModifierType.Pierce, 1.0f));
                break;
            case SelectedCharacter.XERXES:
                decorObject = Instantiate(Resources.Load("CharacterDecor/Xerxes") as GameObject, decor);
                characterMods.Add(new Modifier(ModifierType.MaxHealth, -99.0f));
                characterMods.Add(new Modifier(ModifierType.Damage, 0.3333f));
                characterMods.Add(new Modifier(ModifierType.Speed, 0.5f));
                characterMods.Add(new Modifier(ModifierType.RollCharges, 2.0f));
                break;
            case SelectedCharacter.KYLE:
                decorObject = Instantiate(Resources.Load("CharacterDecor/Kyle") as GameObject, decor);
                characterMods.Add(new Modifier(ModifierType.ClipSize, 0.5f));
                characterMods.Add(new Modifier(ModifierType.CooldownReduction, 0.25f));
                characterMods.Add(new Modifier(ModifierType.CritChance, 0.25f));
                characterMods.Add(new Modifier(ModifierType.Damage, 0.25f));
                characterMods.Add(new Modifier(ModifierType.Discount, 0.25f));
                characterMods.Add(new Modifier(ModifierType.MaxHealth, 20.0f));
                characterMods.Add(new Modifier(ModifierType.Pierce, 1.0f));
                characterMods.Add(new Modifier(ModifierType.ProjectileSpeed, 0.25f));
                characterMods.Add(new Modifier(ModifierType.RateOfFire, 0.25f));
                characterMods.Add(new Modifier(ModifierType.ReloadTime, 0.25f));
                characterMods.Add(new Modifier(ModifierType.Speed, 0.25f));
                characterMods.Add(new Modifier(ModifierType.Vampirism, 0.02f));
                characterMods.Add(new Modifier(ModifierType.RollCharges, 2.0f));
                break;

            default: // If character somehow fails then default to Rambo's abilties
            case SelectedCharacter.RAMBO:
                decorObject = Instantiate(Resources.Load("CharacterDecor/Rambo") as GameObject, decor);
                characterMods.Add(new Modifier(ModifierType.Speed, 0.25f));
                characterMods.Add(new Modifier(ModifierType.ProjectileSpeed, 0.25f));
                break;
        }

        // Give special abilities on first level
        if (PlayerController.instance != null && GameManager.GMinstance.level == 1)
        {
            if (characterAbility == null) characterAbility = Instantiate(Resources.Load("CharacterDecor/DefaultStim") as GameObject); // If no ability was assigned give the character health stims
            PickupAbility(characterAbility.GetComponent<BaseActivePowerup>()); // Equip the ability on the player

            Debug.Log("Added Modifiers because 1st level");
            foreach (Modifier modifier in characterMods) // Apply each modifier listed onto the plauer
            {
                AddModifier(modifier.type, modifier.value);
            }
        }
    }

#region WeaponCode
    // Pickup a given weapon
void PickupWeapon(BaseWeapon _droppedWeapon)
    {
        if(_droppedWeapon == null) { return; }

        // Play swap animation for the weapon
        if(_droppedWeapon.GetSwapAnimName() != "")
        {
            animator.Play(_droppedWeapon.GetSwapAnimName());
        }
        else // Play pistol anim if missing
        {
            animator.Play("PistolSwap");
        }

        if (primaryWeapon == null && secondaryWeapon == null)
        {
            //No weapons, so add the weapon and put it in the primary slot
            //add weawpon
            primaryWeapon = _droppedWeapon;
            _droppedWeapon.OnPickup();
            //Put it in slot
            _droppedWeapon.transform.parent = weaponParent;
            _droppedWeapon.transform.position = weaponParent.position;
            _droppedWeapon.transform.rotation = weaponParent.rotation;
        }
        else if (primaryWeapon != null && secondaryWeapon == null)
        {
            //One weapon
            //add the weapon and put it in the primary slot
            //and move the current weapon to the secondary slot

            //Move weapon references
            secondaryWeapon = primaryWeapon;
            primaryWeapon = _droppedWeapon;
            primaryWeapon.OnPickup();
            //Move old weapon to secondary slot
            secondaryWeapon.transform.parent = secondaryParent;
            secondaryWeapon.transform.position = secondaryParent.position;
            secondaryWeapon.transform.rotation = secondaryParent.rotation;
            secondaryWeapon.OnStow();
            //Move new weapon to primary slot
            primaryWeapon.transform.position = weaponParent.position;
            primaryWeapon.transform.parent = weaponParent;
            _droppedWeapon.transform.rotation = weaponParent.rotation;
        }
        else if (primaryWeapon != null && secondaryWeapon != null)
        {
            //Two weapons
            //Equip new weapon in primary slot, and drop curr primary weapon

            //Remove primary weapon
            primaryWeapon.OnDrop();
            //Set new weapon
            primaryWeapon = _droppedWeapon;
            primaryWeapon.OnPickup();
            //Set pos
            primaryWeapon.transform.position = weaponParent.position;
            primaryWeapon.transform.parent = weaponParent;
            _droppedWeapon.transform.rotation = weaponParent.rotation;
        }
        else
        {
            Debug.Log("wtf");
        }

    }

    // Checks for any weapon inputs
    void UpdateWeapon()
    {
        //Check for inputs
        if(primaryWeapon == null) { return; }
        //Mouse0
        if (!isRolling && weaponSwapTime + 0.4f <= Time.unscaledTime)
        {
            if (Input.GetMouseButton(0) || Input.GetAxisRaw("Fire1") > 0)
            {
                primaryWeapon.OnFireOneHeld();
            }
            if (Input.GetMouseButtonDown(0))
            {
                primaryWeapon.OnFireOneDown();
            }
            if (Input.GetMouseButtonUp(0))
            {
                primaryWeapon.OnFireOneUp();
            }
            //Mouse1
            if (Input.GetMouseButton(1) || Input.GetAxisRaw("Fire2") > 0)
            {
                primaryWeapon.OnFireTwoHeld();
            }
            if (Input.GetMouseButtonDown(1))
            {
                primaryWeapon.OnFireTwoDown();
            }
            if (Input.GetMouseButtonUp(1))
            {
                primaryWeapon.OnFireTwoUp();
            }
            //Reload
            if (Input.GetButton("Reload"))
            {
                primaryWeapon.OnReloadHeld();
            }
            if (Input.GetButtonDown("Reload"))
            {
                primaryWeapon.OnReloadDown();
            }
            if (Input.GetButtonUp("Reload"))
            {
                primaryWeapon.OnReloadUp();
            }
        }
    }

    // Switches between the 2 equipped weapons
    void SwitchWeapon()
    {
        if (secondaryWeapon == null) { return; }

        // Cannot rapidly scroll between weapons
        if (scrollTimer > 0)
        {
            scrollTimer -= Time.unscaledDeltaTime;
            return;
        }
        if (Input.mouseScrollDelta.y == 0)
        {
            return;
        }
        scrollTimer = 0.1f;

        //Swap references to the weapons
        Debug.Log("Weapon swapped");
        BaseWeapon temp = primaryWeapon;
        primaryWeapon = secondaryWeapon;
        secondaryWeapon = temp;

        //Swap positions
        primaryWeapon.transform.parent = weaponParent;
        primaryWeapon.transform.position = weaponParent.transform.position;
        primaryWeapon.transform.rotation = weaponParent.transform.rotation;

        secondaryWeapon.transform.parent = secondaryParent;
        secondaryWeapon.transform.position = secondaryParent.transform.position;
        secondaryWeapon.transform.rotation = secondaryParent.transform.rotation;

        // Equipd and stow the weapons
        primaryWeapon.OnEquip();
        secondaryWeapon.OnStow();

        // Play weapon swap animations
        animator.speed = 1;
        string animName = primaryWeapon.GetSwapAnimName();
        if(animName == null)
        {
            animator.Play("PistolSwap");
        }
        else
        {
            animator.Play(animName);
        }

        // Reset timer
        weaponSwapTime = Time.unscaledTime;
    }

    // Set the main weapon on the player. Used by game manager
    public void SetMainWeapon(GameObject weapon)
    {
        if(weapon.TryGetComponent<BaseWeapon>(out BaseWeapon newWeapon))
        {
            if(primaryWeapon != null)
            {
                //Delete the current primary weapon
                Destroy(primaryWeapon.gameObject);
            }

            //Set the new weapon to the primary weapon
            primaryWeapon = newWeapon;
            primaryWeapon.OnPickup();
                
            //Put new weapon into slot
            primaryWeapon.transform.parent = weaponParent;
            primaryWeapon.transform.position = weaponParent.position;
            primaryWeapon.transform.rotation = weaponParent.rotation;
        }
    }
    // Same as above but for secondary weapon
    public void SetSecondaryWeapon(GameObject weapon)
    {
        if(weapon.TryGetComponent<BaseWeapon>(out BaseWeapon newWeapon))
        {
            if(secondaryWeapon != null)
            {
                //Delete the current primary weapon
                Destroy(secondaryWeapon.gameObject);
            }
            
            //Set the new weapon to the primary weapon
            secondaryWeapon = newWeapon;
            secondaryWeapon.OnPickup();
                
            //Put new weapon into slot
            secondaryWeapon.transform.parent = secondaryParent;
            secondaryWeapon.transform.position = secondaryParent.position;
            secondaryWeapon.transform.rotation = secondaryParent.rotation;
        }
    }

    // Get the sprite of the main weapon for the HUD
    public Sprite GetMainWeaponSprite()
    {
        return primaryWeapon.weaponSprite;
    }

    // Returns the main / secondary weapon reference
    public BaseWeapon GetMainWeapon()
    {
        return primaryWeapon;
    }
    public BaseWeapon GetSecondaryWeapon()
    {
        return secondaryWeapon;
    }

    // Enables or disabled the ability to fire weapons
    public void EnableWeapons(bool a_enabled)
    {
        canUseWeapons = a_enabled;
    }
    #endregion

    // Resets the players animation state
    public void ResetPlayerAnimationState()
    {
        animator = this.GetComponent<Animator>(); // Get animator
        
        // Reset primarys collider and state and start idle anim
        if(primaryWeapon != null)
        {
            primaryWeapon.GetComponent<Collider>().enabled = false;
            primaryWeapon.GetComponent<BaseWeapon>().currState = BaseWeapon.WeaponState.EQUIPPED;
            animator.Play(primaryWeapon.GetIdleAnimName());
        }
        // Disable secondarys collider and stow it
        if(secondaryWeapon != null)
        {
            secondaryWeapon.GetComponent<Collider>().enabled = false;
            secondaryWeapon.OnStow();
        }
    }

    void OnDrawGizmos()
    {
        //Draw aim pos
        if(aimPos == null){return;}
        Gizmos.DrawWireCube(aimPos,Vector3.one * 0.5f);
        Gizmos.DrawLine(transform.position, aimPos);
    }

}

public enum PlayerMoveDirection
{
    Forwards,
    Backwards,
    Left,
    Right,
    None
}
</code></pre>
                                                </div>
                                            </div>
                                        </div>

                                        <div class = "gif__content">
                                            <img src = "images/Player Movement.gif" alt = "Player Movement">
                                            <img src = "images/Player Rolls.gif" alt = "Player Dodge">
                                            <img src = "images/Player Weapon And Weapon Switching.gif" alt = "Weapon Switching">
                                        </div>
                                    </div>
                                </div>

                                <div class = "dropdown">
                                    <button class = "dropdown__button green">
                                        Weapons
                                    </button>
                                    <div class = "dropdown__content">

                                        <div class = "gif__banner">
                                            <img src = "images/Weapons.gif" alt = "Modifiers">
                                        </div> 

                                        <div class = "dropdown__text">
                                            The weapons within the game are built upon 2 of 3 base classes.<br/>
                                            The Base Weapon class holds all of the base requirements for any weapon within the game such as the weapon audio,
                                            different weapon reticles and each weapon's flavour/pickup text.<br/>
                                            This class also contains virtual functions for all firing and reloading scripts acting as a template class for other weapon bases.<br/>
                                            This Base Weapon Class can be seen below.<br/>
                                        </div>

                                        <div class = "dropdown">
                                            <button class = "dropdown__button lightblue" style = "scale: 80%;">
                                                Base Weapon Code
                                            </button>
                                            <div class = "dropdown__content">
                                                <div class = "dropdown__codeblock">
<pre><code class="language-csharp">
    //Base class for all weapons 
    public class BaseWeapon : MonoBehaviour
    {
        public int weaponID; // ID of the weapon
        public bool weaponIsHeldInPistolPos;
        #region WeaponIDs
        /*
         * 0 Basic Gun
         * 1 Ak-47
         * 2 Shotgun
         * 3 Sniper
         * 4 Flamethrower
         * 5 Minigun
         * 6 RPG
         * 7 Laser
         * 8 Boomerang Launcher
         * 9 Bounce Gun
         * 10 Shatter Cannon
         * 11 Goose Gun
         * 12 Katana
         */
        #endregion
        public List<AudioClip> fireAudioClips = null;
        public List<AudioClip> reloadAudioClips = null;
        public Texture2D weaponCursor;
        protected int audioCounter = 0;
    
        private float bobSpeed;
    
        //Modifiers
        private float damageModifier = 1.0f;
        private float rofModifier = 1.0f;
        private float speedModifier = 1.0f;
        private float reloadSpeedModifier = 1.0f;
        private float magSizeModifier = 1.0f;
    
        // Description
        public string weaponName = ""; // Name of the powerup in item desc box
    
        [TextArea(15, 20)]
        public string weaponDescription = ""; // Description of the powerup in item desc box
        public Sprite weaponSprite = null; // Weapon icon
        protected GameObject descriptionBox;
    
        //State
        public enum WeaponState
        {
            EQUIPPED,
            STOWED,
            DROPPED
        }
        public WeaponState currState = WeaponState.DROPPED;
    
        //Virtual functions
        public virtual void OnFireOneHeld() {}
        public virtual void OnFireOneDown() {}
        public virtual void OnFireOneUp() { }
        public virtual void OnFireTwoHeld() { }
        public virtual void OnFireTwoDown() {}
        public virtual void OnFireTwoUp() { }
        public virtual void OnReloadHeld() { }
        public virtual void OnReloadDown() {}
        public virtual void OnReloadUp() { }
        public virtual void OnReloadCancel() { }
        public virtual void SetModifiers() { }
        public virtual string GetSwapAnimName(){return "";}
        public virtual string GetIdleAnimName(){return "";}
        public virtual void OnStow()
        {
            currState = WeaponState.STOWED;
        }
        public virtual void OnEquip()
        {
            currState = WeaponState.EQUIPPED;
            //CursorController.instance.SetCursor(weaponCursor);
            GameManager.GMinstance.GetComponent<Crosshair>().SetCrosshair();
        }
        public virtual void OnPickup()
        {
            this.GetComponent<Collider>().enabled = false;
            currState = WeaponState.EQUIPPED;
            RemoveDescBox();
            if (GameManager.GMinstance.weaponsPickedUp.Length - 1 >= weaponID)
            {
                GameManager.GMinstance.weaponsPickedUp[weaponID] = true;
            }
            //CursorController.instance.SetCursor(weaponCursor);
            GameManager.GMinstance.GetComponent<Crosshair>().SetCrosshair();
        }
        public virtual void OnDrop()
        {
            currState = WeaponState.DROPPED;
            this.GetComponent<Collider>().enabled = true;
            transform.parent = null;
            Vector3 pos = transform.position;
            pos.y = 0.5f;
            transform.position = pos;
            SpawnDescBox();
        }
    
        public virtual void PlayAudio(List<AudioClip> audioClips)
        {
            if (audioClips.Count > 0)
            {
                //get random audio 
                int randAudio = Random.Range(0, audioClips.Count);
                //Play Reload Audio clip on reload
                if (gameObject.TryGetComponent(out AudioSource audioSource))
                {
                    audioSource.clip = audioClips[randAudio];
                    //audioSource.time = 0.3f;
                    audioSource.volume = GameManager.GMinstance.FXVolume;
                    audioSource.Play();
                }
            }
        }
    
        public virtual void Idle()
        {
            transform.rotation = Quaternion.Euler(0, transform.rotation.eulerAngles.y + (50 * Time.unscaledDeltaTime), 0);
    
            if (transform.position.y >= 1.2f)
            {
                bobSpeed = -0.5f;
            }
            else if (transform.position.y <= 0.8f)
            {
                bobSpeed = 0.5f;
            }
    
            transform.position = new Vector3(transform.position.x, transform.position.y + (bobSpeed * Time.unscaledDeltaTime), transform.position.z);
        }
    
        public virtual bool isEquipped()
        {
            if(currState == WeaponState.EQUIPPED)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    
        public void SpawnDescBox()
        {
            if(ItemPopupController.instance == null){Debug.Log("null");}
            ItemPopupController.instance.AddBox(weaponName, weaponDescription, transform.position);
        }
        public void RemoveDescBox()
        {
            if(ItemPopupController.instance == null){Debug.Log("null");}
            ItemPopupController.instance.RemoveBox(weaponName, weaponDescription, transform.position);
        }
    
        public string GetDescription()
        {
            return weaponDescription;
        }
    }
</code></pre>
                                                </div>
                                            </div>
                                        </div>

                                        <div class = "dropdown__text">
                                            Off of this base weapon class both the "Projectile" and "Beam" weapon base classes are built.<br/>
                                            These classes serve as the actual base for most weapons within the game, containing the complete functions for firing and reloading.
                                            This allows for the easy creation and itteration of new weapons from these base classes.<br/>
                                        </div>

                                        <div class = "gif__content">
                                            <img src = "images/Rifle.gif" alt = "Rifle">
                                            <img src = "images/Cannon.gif" alt = "Shattercannon">
                                            <img src = "images/Laser.gif" alt = "Laser">
                                        </div>

                                        <div class = "dropdown__text">
                                            Both of these classes are shown below.<br/>
                                        </div>

                                        <div class = "dropdown">
                                            <button class="dropdown__button lightblue" style = "scale: 80%;">
                                                Projectile Weapon Base
                                            </button>
                                            <div class = "dropdown__content">
                                                <div class = "dropdown__codeblock">
<pre><code class="language-csharp">
    public class ProjectileWeapon : BaseWeapon
    {
        public Transform spawnLocation;
        public GameObject projectilePrefab;
        public GameObject muzzleFlash;
        public float rateOfFire = 0.2f;
        public float speed;
        public float accel;
        public float lifetime;
        public float dmg;
        public float spreadInDegrees = 0;
        protected float baseDmg;
        public int magazineSize = 8;
        public float reloadDuration = 1;
        protected float reloadTimer = 0;
        protected int currMagSize = 8;
        [Range(0,1)]
        public float critChance = 0.1f;
        public float critMultiplier = 1.25f;
        private float time = 0;
        public string shootAnimName ="";
        public string reloadAnimName = "";
        public string swapToAnimName = "";
        public string idleAnimName = "";
        public bool poolObjects = false; // True if weapon uses object pooling
        protected int poolIndex = 0; // Current index in array
        public int poolSize = 5; // Size of pool
        public GameObject[] projPool; // Array containing all pooled projectiles
        private Animator animator;
        protected reloadState currReloadState = reloadState.READY;
        protected enum reloadState
        {
            READY,
            RELOADING
        }
        private void Start()
        {
            projPool = new GameObject[poolSize];
            animator = PlayerController.instance.gameObject.GetComponent<Animator>();
            currMagSize = magazineSize + (int)(magazineSize * PlayerController.instance.GetModifier(ModifierType.ClipSize));
            baseDmg = dmg;
        }
    
        public override void OnFireOneHeld()
        {
            if (Time.unscaledTime - time < rateOfFire * (PlayerController.instance.GetModifier(ModifierType.RateOfFire)) || currReloadState == reloadState.RELOADING) { return; }
    
            if (currMagSize < 1)
            {
                OnReloadDown();
                return;
            }
    
            time = Time.unscaledTime;
            if (shootAnimName != "")
            {
                animator.speed = 1 / (rateOfFire * (PlayerController.instance.GetModifier(ModifierType.RateOfFire)));
                animator.Play(shootAnimName);
            }
            OnShoot();
            MagazineUIController.instance.RefreshMagazineUI(magazineSize + (int)(magazineSize * PlayerController.instance.GetModifier(ModifierType.ClipSize)), currMagSize);
        }
        protected virtual void OnShoot()
        {
            GameObject projectile;
    
            // Object pooling
            if (poolObjects)
            {
                // If index in pool array is empty, instantiate new projectile and add it to the pool array
                if (projPool[poolIndex] == null)
                {
                    projectile = Instantiate(projectilePrefab, spawnLocation.position, spawnLocation.rotation);
                    projPool[poolIndex] = projectile;
                }
                // If index in pool array isnt empty, reinitialise the projectile
                else
                {
                    projectile = projPool[poolIndex];
                    projectile.GetComponent<Projectile>().Enable(spawnLocation);
                }
                poolIndex = (poolIndex + 1) % projPool.Length;
            }
    
            // Just instantiate if object pooling isnt being used (only applies to katana really, and that overrides this function anyway)
            else
            {
                projectile = Instantiate(projectilePrefab, spawnLocation.position, spawnLocation.rotation);
            }
    
            //Play weapon fire audio
            PlayAudio(fireAudioClips);
    
            float spread = Random.Range(-spreadInDegrees/2,spreadInDegrees/2);
            Vector3 angle = spawnLocation.transform.eulerAngles;
            angle.y += spread;
            projectile.transform.eulerAngles = angle;
            projectile.GetComponent<Projectile>().Init(speed * (1 + PlayerController.instance.GetModifier(ModifierType.ProjectileSpeed)), accel, lifetime, 
                dmg * (1 + PlayerController.instance.GetModifier(ModifierType.Damage)), PlayerController.instance.gameObject, poolObjects)
            .SetCrit(GetIsCrit(), critMultiplier)
            .SetPierce((int)PlayerController.instance.GetModifier(ModifierType.Pierce), 1.0f);
            currMagSize--;
    
            //Play VFX
            if(muzzleFlash == null) { return; }
            VisualEffect vfx;
            if (muzzleFlash.TryGetComponent<VisualEffect>(out vfx))
            {
                vfx.Play();
            }
            ParticleSystem pSystem;
            if (muzzleFlash.TryGetComponent<ParticleSystem>(out pSystem))
            {
                pSystem.Play();
            }
            return;
        }
        public override void OnReloadDown()
        {
            if(currReloadState == reloadState.RELOADING) { return; }
    
            //Play weapon reload audio
            PlayAudio(reloadAudioClips);
    
            ReloadAnimation.instance.BeginAnimation(reloadDuration / (1 + PlayerController.instance.GetModifier(ModifierType.ReloadTime)), 0, 0, false);
            reloadTimer = 0;
            currReloadState = reloadState.RELOADING;
            if (reloadAnimName != "")
            {
                animator.speed = 1 / reloadDuration * (1 + PlayerController.instance.GetModifier(ModifierType.ReloadTime));
                animator.Play(reloadAnimName);
            }
        }
        public override void OnPickup()
        {
            base.OnPickup();
            MagazineUIController.instance.RefreshMagazineUI(magazineSize + (int)(magazineSize * PlayerController.instance.GetModifier(ModifierType.ClipSize)), currMagSize);
        }
        public override void OnEquip()
        {
            base.OnEquip();
            MagazineUIController.instance.RefreshMagazineUI(magazineSize + (int)(magazineSize * PlayerController.instance.GetModifier(ModifierType.ClipSize)), currMagSize);
        }
        public override void OnDrop()
        {
            if (poolObjects)
            {
                // Clear out object pool list
                foreach (GameObject projectile in projPool)
                {
                    Destroy(projectile);
                }
                projPool = new GameObject[poolSize];
            }
    
            base.OnDrop();
        }
        private void Update()
        {
            if (currState == WeaponState.DROPPED)
            {
                Idle();
            }
            UpdateProjectileWeapon();
        }
        protected void UpdateProjectileWeapon()
        {
            switch (currReloadState)
            {
                case reloadState.RELOADING:
                    reloadTimer += Time.unscaledDeltaTime * (1 + PlayerController.instance.GetModifier(ModifierType.ReloadTime));
                    if(reloadTimer < reloadDuration) { break; }
                    currMagSize = magazineSize + (int)(magazineSize * PlayerController.instance.GetModifier(ModifierType.ClipSize));
                    MagazineUIController.instance.RefreshMagazineUI(magazineSize + (int)(magazineSize * PlayerController.instance.GetModifier(ModifierType.ClipSize)), magazineSize + (int)(magazineSize * PlayerController.instance.GetModifier(ModifierType.ClipSize)));
                    reloadTimer = 0;
                    currReloadState = reloadState.READY;
                    OnReloadFinished();
                    break;
                default:
                    return;
            }
        }
        protected virtual void OnReloadFinished()
        {
        }
        public override string GetSwapAnimName()
        {
            return swapToAnimName;
        }
        public override string GetIdleAnimName()
        {
            return idleAnimName;
        }
        protected bool GetIsCrit()
        {
            float rnd = Random.Range(1,100);
            rnd /= 100;
            if(rnd < critChance + PlayerController.instance.GetModifier(ModifierType.CritChance))
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    
        public void SetMagazineSize(int mag)
        {
            magazineSize = mag;
        }
    
    }
</code></pre>
                                                </div>
                                            </div>
                                        </div>

                                        <div class = "dropdown">
                                            <button class="dropdown__button lightblue" style = "scale: 80%;">
                                                Beam Weapon Base
                                            </button>
                                            <div class = "dropdown__content">
                                                <div class = "dropdown__codeblock">
<pre><code class="language-csharp">
    public class BeamWeapon : BaseWeapon
    {
        private float heat = 0;
        private float maxHeat = 1;
        public float heatDissipationRate = 0.33f;
        public float heatBuildupRate = 1f;
        public float forcedDissipateDuration = 2;
        private bool isFiring = false;
        private bool forcedDissipating = false;
        public GameObject laserPrefab;
        private GameObject laserObject;
        public Transform laserStartPos;
        private Transform impactVFX;
        public string coolDownAnimName = "";
        public string shootAnimName = "";
        public string swapAnimName = "";
        public string idleAnimName = "";
        private Animator animator;
        public float tickRate = 5;
        private float tickTimer = 0;
        private bool canDamge = false;
        public float damagePerSecond = 2;
        [Range(0,1)]
        public float critChance = 0.1f;
        public float critMultiplier = 2;
        private enum State
        {
            inactive,
            shooting,
            overheated
        }
        State currentState = State.inactive;
        void Start()
        {
            animator = PlayerController.instance.GetComponent<Animator>();
            currentState = State.inactive;
            laserObject = GameObject.Instantiate(laserPrefab,laserStartPos.position,laserStartPos.rotation);
            laserObject.SetActive(true);
            laserObject.GetComponent<Animator>().Play("Asleep");
            laserObject.transform.parent = laserStartPos;
            impactVFX = laserObject.transform.GetChild(2);
            impactVFX.parent = null;
        }
        void Update()
        {
            if (currState == WeaponState.DROPPED)
            {
                Idle();
            }
    
            laserObject.GetComponent<LineRenderer>().SetPosition(0,laserStartPos.position);
            switch(currentState)
            {
                case State.inactive:
                    //PlayAudio(reloadAudioClips);
                    if (heat <= 0)
                    {
                        heat = 0;
                        HeatIndicator.instance.SetVisible(false);
                        return;
                    }
                    heat -= Time.unscaledDeltaTime * heatDissipationRate;
                    HeatIndicator.instance.SetVisible(true);
                    HeatIndicator.instance.SetHeat(heat,maxHeat);
                    break;
                case State.shooting:
                    HeatIndicator.instance.SetVisible(true);
                    if (gameObject.GetComponent<AudioSource>().isPlaying == false)
                    {
                        PlayAudio(fireAudioClips);
                    }
                    
                    if (heat >= maxHeat)
                    {
                        heat = maxHeat;
                        HeatIndicator.instance.SetCoolingDown(forcedDissipateDuration);
                        laserObject.GetComponent<Animator>().Play("WindDown");
                        animator.Play(coolDownAnimName);
                        currentState = State.overheated;
                        return;
                    }
                    heat += Time.unscaledDeltaTime * heatBuildupRate;
                    GetLaserEndPos();
                    HeatIndicator.instance.SetHeat(heat,maxHeat);
                    break;
                case State.overheated:
                    heat -= Time.unscaledDeltaTime * 1 / forcedDissipateDuration;
                    if(heat <= 0)
                    {
                        currentState = State.inactive;
                        HeatIndicator.instance.SetVisible(false);
                        animator.Play("BeamCooldownDeTransition");
                    }
                    break;
            }
            tickTimer += Time.unscaledDeltaTime;
            if(tickTimer < 1 / tickRate){canDamge = false; return;}
            canDamge = true;
            tickTimer = 0;
        }
        public override void OnFireOneHeld()
        {
            if(currentState != State.overheated)
            {
                laserObject.GetComponent<Animator>().Play("Active");
                currentState = State.shooting;
            }
        }
        public override void OnFireOneDown()
        {
            if(currentState != State.overheated)
            {
                animator.Play(shootAnimName);
            }
        }
        public override void OnFireOneUp()
        {
            if(currentState != State.overheated)
            {
                laserObject.GetComponent<Animator>().Play("WindDown");
                animator.Play(idleAnimName);
                currentState = State.inactive;
            }
        }
        private void GetLaserEndPos()
        {
            RaycastHit hit;
            Vector3 endPos;
            if(Physics.Raycast(laserStartPos.position, laserStartPos.forward, out hit, 100, LayerMask.GetMask("Untraversable", "Player", "Enemy", "Hurtbox", "SeeThrough"), QueryTriggerInteraction.Ignore))
            {
                endPos = hit.point;
                if(hit.collider.gameObject.tag != "Player" && canDamge)
                {
                    if(hit.collider.gameObject.TryGetComponent<Character>(out Character _character))
                    {
                        bool isCrit = GetIsCrit();
                        float _dmg;
                        if(isCrit)
                        {
                            _dmg = damagePerSecond * critMultiplier;
                        }
                        else
                        {
                            _dmg = damagePerSecond;
                        }
                        _dmg *= 1 + PlayerController.instance.GetModifier(ModifierType.Damage);
                        _character.Damage(_dmg / tickRate, true, false, false,EffectType.None,isCrit);
                        tickTimer = 0;
                        canDamge = false;
                    }
                }
            }
            else
            {
                endPos = laserStartPos.position + laserStartPos.forward * 100;
            }
            laserObject.GetComponent<LineRenderer>().SetPosition(1,endPos);
            impactVFX.position = endPos;
            impactVFX.forward = impactVFX.forward * -1;
        }
        public override void OnPickup()
        {
            base.OnPickup();
            MagazineUIController.instance.RefreshMagazineUI(0,0);
        }
        public override void OnEquip()
        {
            base.OnEquip();
            MagazineUIController.instance.RefreshMagazineUI(0,0);
            transform.localPosition = Vector3.zero;
        }
        public override string GetSwapAnimName()
        {
            return swapAnimName;
        }
        public override string GetIdleAnimName()
        {
            return idleAnimName;
        }
        protected bool GetIsCrit()
        {
            float rnd = Random.Range(1,100);
            if(rnd < critChance * 100)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    }
</code></pre>
                                                </div>
                                            </div>
                                        </div>

                                    </div>
                                </div>

                                <div class = "dropdown">
                                    <button class="dropdown__button green">
                                        Powerups/Modifiers
                                    </button>
        
                                    <div class = "dropdown__content">
                                        <div class = "dropdown__text">
                                            The game also contains 2 different types of powerups, modifiers and active powerups.<br/>
                                            Modifiers contain abilities such as, life steal, movement speed buffs, and rate of fire increases. <br/>
                                            Active powerups on the other hand, are activated manually by the player, when wanted.<br/>
                                            They include things such as, a molotov, a portaMorta, and a dumbell powerup (Each shown in the below gifs).<br/>
                                        </div>

                                        <div class = "gif__content">
                                            <img src = "images/Molotov.gif" alt = "Molotov Powerup">
                                            <img src = "images/PortaMorta.gif" alt = "PortaMorta Powerup">
                                            <img src = "images/Dumbell.gif" alt = "Dumbell Powerup">
                                        </div>

                                        <div class = "dropdown__text">
                                            The base code for an active powerup can be seen here.
                                        </div>

                                        <div class = "dropdown">
                                            <button class="dropdown__button lightblue" style = "scale: 80%;">
                                                Base Powerup Code
                                            </button>
                                            <div class = "dropdown__content">
                                                <div class = "dropdown__codeblock">
<pre><code class="language-csharp">
    public class BaseActivePowerup : MonoBehaviour
{
    public int activePowerUpID;
    [SerializeField] protected float cooldown; // Cooldown between uses
    [SerializeField] string powerupName = ""; // Name of the powerup in item desc box
    [SerializeField] string powerupDescription = ""; // Description of the powerup in item desc box
    [SerializeField] Sprite powerupIcon = null; // Icon that displays on ui when this ability is held
    [SerializeField] float equippedSize = 0.5f; // Size to scale up/down to when equipped
    [SerializeField] Vector3 equippedPosition = new Vector3(0.5f, -0.5f, -0.6f); // Position on the player to move to when equipped
    protected bool equipped = false;

    protected void Update()
    {
        if (!equipped)
        {
            transform.position += (Vector3.up * Mathf.Sin(Time.time * 2) / 2) * Time.deltaTime;
        }
    }

    public virtual float UseAbility()
    {
        return cooldown;
    }

    public virtual void Equip()
    {
        if (equipped) return; // Cannot equip same object twice

        equipped = true;
        transform.parent = PlayerController.instance.gameObject.transform.GetChild(0);
        transform.position = PlayerController.instance.gameObject.transform.position + (Quaternion.Euler(PlayerController.instance.transform.rotation.eulerAngles) * equippedPosition);
        transform.localScale *= equippedSize;

        if (GameManager.GMinstance != null)
        {
            GameManager.GMinstance.powerupsPickedUp[activePowerUpID] = true;
        }
        if (ItemPopupController.instance != null)
        {
            ItemPopupController.instance.RemoveBox(powerupName, powerupDescription, transform.position);
        }
    }
    public virtual void Unequip()
    {
        if (!equipped) return; // Cannot unequip a non active ability

        equipped = false;
        transform.parent = null;
        transform.position = PlayerController.instance.transform.position;
        transform.rotation = Quaternion.identity;
        transform.localScale *= 1.0f/equippedSize;

        ItemPopupController.instance.AddBox(powerupName, powerupDescription, transform.position);
    }

    // Getters
    public bool IsEquipped() { return equipped; }
    public float GetCooldownTime() { return cooldown; }
    public Sprite GetSprite() { return powerupIcon; }

    private void OnTriggerEnter(Collider other)
    {
        if (other.gameObject == PlayerController.instance.gameObject)
        {
            ItemPopupController.instance.AddBox(powerupName, powerupDescription, transform.position);
        }
    }
    private void OnTriggerExit(Collider other)
    {
        if (other.gameObject == PlayerController.instance.gameObject)
        {
            ItemPopupController.instance.RemoveBox(powerupName, powerupDescription, transform.position);
        }
    }

    public string GetDescription()
    {
        return powerupDescription;
    }

    public string GetTitle()
    {
        return powerupName;
    }
}
</code></pre>
                                                </div>
                                            </div>
                                        </div>

                                        <div class = "dropdown__text">
                                            Conversely, modifiers are stored as a dictionary of values, these can then be called to when applied to players or enemies.
                                            When collected by the player the modifier checks the dictionary for the selected modifier then checks the range for the modifier's variance.<br/>
                                            Once this is done the modifier's Type and value are added to a list of modifiers on the player character.
                                            When actions are then called on the player the appropriate modifiers are then taken from this list and applied to the action. <br/>
                                        </div>

                                        <div class = "gif__banner">
                                            <img src = "images/Modifiers.gif" alt = "Modifiers">
                                        </div>    
                                        
                                        <div class = "dropdown__text">
                                            The code for each modifier's base can be found here.<br/>
                                        </div>

                                        <div class = "dropdown">
                                            <button class="dropdown__button lightblue" style = "scale: 80%;">
                                                Base Modifier Code
                                            </button>
                                            <div class = "dropdown__content">
                                                <div class = "dropdown__codeblock">
<pre><code class="language-csharp">
    public class BasePowerup : MonoBehaviour
{
    public int powerupID;
    [SerializeField] ModifierType modType; // Modifier that will be changed
    [SerializeField] protected float modAmount = 0.0f; // Amount of the modifier that will be changed
    [SerializeField] protected float modVariation = 0.0f; // +/- difference added onto the mod amount for variety among powerups
    [SerializeField] string pickupText = ""; // Text that displays after the number
    [SerializeField] string powerupName = ""; // Name of the powerup in item desc box
    [SerializeField] string powerupDescription = ""; // Description of the powerup in item desc box

    int playerRange = 0; // How close the player is to powerup. 0 = out of range, 1 = close enough for description to pop up, 2 = close enough to pick up
    GameObject itemDescBox;

    protected void Update()
    {
        // Idle float animation
        transform.position += (Vector3.up * Mathf.Sin(Time.time * 2) / 2) * Time.deltaTime;
    }

    // Virtual OnPickup function. Changed by any child classes for their own respective extra effects.
    // Most powerups just change a modifier though, so the code here will be fine on it's own
    protected virtual bool OnPickup()
    {
        if (GameManager.GMinstance != null)
        {
            GameManager.GMinstance.powerupsPickedUp[powerupID] = true;
        }
        PlayerController.instance.AddModifier(modType, modAmount);
        return true;
    }

    // Called when the player enters/exits a powerup trigger box
    private void TriggerUpdate()
    {
        // Player has walked into item description range
        if (playerRange > 0)
        {
            // Spawn item box
            ItemPopupController.instance.AddBox(FormatText(powerupName), FormatText(powerupDescription), transform.position);

            // Player has walked into pick up range
            if (playerRange == 2) 
            {
                // Run pickup code. If OnPickup() returns false then the pickup will not be used
                if (!OnPickup()) return;

                // Play pickup sound effect
                PlayerController.instance.PlayItemPickup();

                // Paste text onto floating text if possible
                if (ProjectileLibrary.instance != null)
                {
                    GameObject createdText = Instantiate(ProjectileLibrary.instance.GetProjectile(Projectiles.FLOATING_TEXT), PlayerController.instance.transform.position + Vector3.up * 2.0f, Quaternion.Euler(45.0f, 0.0f, 0.0f));
                    createdText.GetComponent<ItemPickupFade>().SetText(FormatText(pickupText));
                }

                // Destroy item description box
                ItemPopupController.instance.RemoveBox(FormatText(powerupName), FormatText(powerupDescription), transform.position);

                // Destroy pickup
                Destroy(gameObject);
            }
        }
        else
        {
            // Destroy item description box
            ItemPopupController.instance.RemoveBox(FormatText(powerupName), FormatText(powerupDescription), transform.position);
        }
    }
    protected void OnTriggerEnter(Collider other)
    {
        // Check if player has walked into trigger
        if (other.gameObject == PlayerController.instance.gameObject)
        {
            playerRange++;
            TriggerUpdate();
        }
    }
    protected void OnTriggerExit(Collider other)
    {
        // Check if player has walked out of trigger
        if (other.gameObject == PlayerController.instance.gameObject)
        {
            playerRange--;
            TriggerUpdate();
        }
    }

    // Lets other code change the values on the powerup for "variety"
    public void SetModAmount(float a_modAmount)
    {
        modAmount = a_modAmount;
    }
    public void RandomiseModAmount()
    {
        modAmount += Random.Range(-modVariation, modVariation); ;
    }

    // Inserts number values into text
    private string FormatText(string inputString)
    {
        return inputString
            .Replace("{percent}", Mathf.Round(modAmount * 100.0f).ToString() + "%")
            .Replace("{integer}", Mathf.Round(modAmount).ToString())
            .Replace("{-percent}", Mathf.Round(modAmount * -100.0f).ToString() + "%")
            .Replace("{float}", (System.Math.Round(modAmount, 2)).ToString()); // rounds to 2 decimal points
    }

    // Inserts number values into text. Shows modAmount values including ranges as opposed to just single value
    private string FormatTextRange(string inputString)
    {
        if (modVariation == 0.0f) return FormatText(inputString); // If no variation in potential power-up values, do not try to display a range
        return inputString
            .Replace("{percent}", Mathf.Round((modAmount - modVariation) * 100.0f).ToString() + "-" + Mathf.Round((modAmount + modVariation) * 100.0f).ToString() + "%")
            .Replace("{integer}", Mathf.Round(modAmount - modVariation).ToString() + "-" + Mathf.Round(modAmount + modVariation).ToString())
            .Replace("{-percent}", Mathf.Round((modAmount - modVariation) * -100.0f).ToString() + "-" + Mathf.Round((modAmount + modVariation) * -100.0f).ToString() + "%")
            .Replace("{float}", (System.Math.Round((modAmount - modVariation), 2)).ToString() + "-" + (System.Math.Round((modAmount + modVariation), 2)).ToString()); // rounds to 2 decimal points
    }

    public string GetDescription()
    {
        return powerupDescription;
    }

    public string GetDescriptionEncyclopedia()
    {
        return FormatTextRange(powerupDescription);
    }

    public string GetTitle()
    {
        return powerupName;
    }
}
</code></pre>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class = "dropdown">
                            <button class="dropdown__button green">
                                Extra Contributions
                            </button>
                            <div class = "dropdown__content">
                                <div class = "dropdown__text">
                                    Ontop of each of these I assited in the creation of various enemy behaviours, level generation seeding, 
                                    leaderboards, achievement management and sound systems implemented during the game's development.<br/>
                                    These aren't included here as the parts of them coded by me, is now either spread throughout the systems making it 
                                    difficult to display my contributions,
                                    or has been retired in favour of newer and more clean solutions.<br/><br/>
                                    Instead I'm including a few GIFs of the working verisons of enemy behaviours, level gen, and weather, all running on my old code below.<br/>
                                </div>

                                <div class = "gif__content">
                                    <img src = "images/Boss Behaviours.gif" alt = "Boss Behaviours">
                                    <img src = "images/Map Generation.gif" alt = "Map Generation">
                                    <img src = "images/Weather.gif" alt = "Weather">
                                </div>
                            </div>
                        </div>
                    </p>
            </div>
        </div>
    </section>
    <script src="app.js"></script>
</body>
</html>